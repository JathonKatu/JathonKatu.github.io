{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/jquery-3.6.4.min.js","path":"js/jquery-3.6.4.min.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"b108304e4179cc4bc24287cbfca52df25dded403","modified":1758349085581},{"_id":"themes/landscape/.npmignore","hash":"4c40eab00f24304ca400313319c58d461788ff5e","modified":1758252604854},{"_id":"themes/landscape/README.md","hash":"e32630175e6d84257c242fd942e39c772fd429da","modified":1758252604855},{"_id":"themes/landscape/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1758252604854},{"_id":"themes/landscape/_config.yml","hash":"1d42cdc1e7854dd091c8d306f95c4c502d2071de","modified":1758252604855},{"_id":"themes/landscape/.gitignore","hash":"dde61fc2d985d9256a5041e55b285d6803b9010d","modified":1758252604854},{"_id":"themes/landscape/.github/dependabot.yml","hash":"055a7e8776cb1e01c2c489fee80f3e51472a683c","modified":1758252604831},{"_id":"themes/landscape/package.json","hash":"ec6646daaa2795a4fb153673e346660ecd639531","modified":1758252604935},{"_id":"themes/landscape/languages/de-DE.yml","hash":"d29d1c4256b7ed9df42f511c2ff0a23ad5fd6c1f","modified":1758252604856},{"_id":"themes/landscape/languages/de.yml","hash":"d45cea36c5c83d7d09afcd1c26fff4a4c513c25b","modified":1758252604856},{"_id":"themes/landscape/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1758252604856},{"_id":"themes/landscape/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1758252604856},{"_id":"themes/landscape/languages/en.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1758252604888},{"_id":"themes/landscape/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1758252604857},{"_id":"themes/landscape/languages/es.yml","hash":"e3b4937da4cd2d0393b8a0ba310e70fc605cc431","modified":1758252604888},{"_id":"themes/landscape/languages/es-ES.yml","hash":"7008a8fc91f18d2a735864817b8ebda30c7a2c66","modified":1758252604888},{"_id":"themes/landscape/languages/fr-FR.yml","hash":"8d09dbdab00a30a2870b56f7c0a7ca7deafa7b88","modified":1758252604888},{"_id":"themes/landscape/languages/hu-HU.yml","hash":"712d18664898fa21ba38d4973e90ef41a324ea25","modified":1758252604889},{"_id":"themes/landscape/languages/fr.yml","hash":"8cb0fe4b6913b4d5b662cdd0108a923c90025f85","modified":1758252604888},{"_id":"themes/landscape/languages/hu.yml","hash":"d22ec72d00567db3782661ab5ccdb2475469da4c","modified":1758252604889},{"_id":"themes/landscape/languages/it-IT.yml","hash":"2cb6dc2fab9bd2dbe1c8bb869a9e8bf85a564fdd","modified":1758252604889},{"_id":"themes/landscape/languages/it.yml","hash":"7f09aa0520688e2de50cb5b6631998682f9200f5","modified":1758252604889},{"_id":"themes/landscape/languages/ja-JP.yml","hash":"08481267e0c112e1f6855620f2837ec4c4a98bbd","modified":1758252604890},{"_id":"themes/landscape/languages/ko-KR.yml","hash":"19209ad8f9d4057e8df808937f950eb265e1db69","modified":1758252604892},{"_id":"themes/landscape/languages/ko.yml","hash":"11330316e3c1262474a2b496e40dbc29f93fe01b","modified":1758252604893},{"_id":"themes/landscape/languages/ja.yml","hash":"3e2fedca096678c0c234ebffa4637828979296fa","modified":1758252604891},{"_id":"themes/landscape/languages/mn.yml","hash":"088c2507d8f221416f99cf72d73641ba476a0f00","modified":1758252604895},{"_id":"themes/landscape/languages/mn-MN.yml","hash":"b9e5f3e7c0c2f779cf2cfded6db847b5941637ca","modified":1758252604894},{"_id":"themes/landscape/languages/nl-NL.yml","hash":"5ebbc30021f05d99938f96dfff280392df7f91f0","modified":1758252604896},{"_id":"themes/landscape/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1758252604898},{"_id":"themes/landscape/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1758252604897},{"_id":"themes/landscape/languages/pt.yml","hash":"ae2c61b30e638f74f1a42c9ce39ac08d063b30f5","modified":1758252604900},{"_id":"themes/landscape/languages/pt-PT.yml","hash":"0f852b6b228e6ea59aa3540574bb89b233f2a098","modified":1758252604899},{"_id":"themes/landscape/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1758252604901},{"_id":"themes/landscape/languages/th-TH.yml","hash":"ebfdba9bc4842c829473c1e6e4544344f182724d","modified":1758252604901},{"_id":"themes/landscape/languages/ru-RU.yml","hash":"360d11a28bb768afb1dd15f63fa7fd3a8cc547ee","modified":1758252604900},{"_id":"themes/landscape/languages/th.yml","hash":"84a55b00aa01f03982be294e43c33a20e6d32862","modified":1758252604901},{"_id":"themes/landscape/layout/archive.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1758252604932},{"_id":"themes/landscape/languages/tr.yml","hash":"424f6e94ced575b51bb7dcebdc0f25d4f4c99fe2","modified":1758252604901},{"_id":"themes/landscape/layout/category.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1758252604933},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1758252604902},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"e41d1e0e3a9e15c30b7142491bed39dc50371e96","modified":1758252604902},{"_id":"themes/landscape/scripts/fancybox.js","hash":"113012153240fa62a2dffc85b1dd6a476609670a","modified":1758252604935},{"_id":"themes/landscape/layout/index.ejs","hash":"57281fc3812c877ec2d8e89ec87ede57b9789d4c","modified":1758252604933},{"_id":"themes/landscape/layout/layout.ejs","hash":"99ad49cb7ee932c62ab0ef3a4de71f7e7e8c6bed","modified":1758252604933},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1758252604934},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1758252604935},{"_id":"themes/landscape/.github/workflows/deploy.yml","hash":"b799ce8c96f9dac93b32684c3ca1d92de2ede567","modified":1758252604831},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1758252604902},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"0111bb3084675d00664342c03e2020de520473fc","modified":1758252604902},{"_id":"themes/landscape/layout/tag.ejs","hash":"97160b8111dd0283f8231408bcab4c87d31c1646","modified":1758252604935},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"165008f72ed77f0da879d132563d763369d26472","modified":1758252604904},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"f8791a133bb45633e58b198db9959e2f873ee641","modified":1758252604903},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"47e22ba6c0ebb47bbcd788cc1a1a1ddaadc244e0","modified":1758252604903},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"9fc18f1fd5bec16f8a3d30b0ce38458485c398b3","modified":1758252604904},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"403e107162a13bd8db2fc97f2f85df5b235f9308","modified":1758252604904},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1758252604929},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"0fe1e52c291c9499bd05b966e0b9aac5be351c58","modified":1758252604931},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"892a5b524a508f395f6d72cb6721f0a3db14d4d7","modified":1758252604929},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"50e7a7de24edc42e96cc4adae17c38e059781f1b","modified":1758252604905},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1758252604931},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1758252604945},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"98c85af1103af18b02c4f5f207fdfc48e207d794","modified":1758252604932},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1758252604932},{"_id":"themes/landscape/source/css/_variables.styl","hash":"a4b3530798b0a7a23d31fb0b86b530fcc2fce87a","modified":1758252604941},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1758252604932},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1758252604932},{"_id":"themes/landscape/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1758252604935},{"_id":"themes/landscape/source/css/style.styl","hash":"15535c222f5a689c255c77722d2334bb1ac97a7e","modified":1758252604944},{"_id":"themes/landscape/source/js/script.js","hash":"0b5bd5ce6783a733607a62c5273486d8893571c6","modified":1758252604947},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1758252604930},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"e78bda05fcf57b0e5e3a20cf3505d37fd69aaf46","modified":1758252604930},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1758252604930},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1758252604930},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1758252604931},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"9e574d8eb1a5285ec3b4346607414770d2f7e0ff","modified":1758252604937},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"02f477f2ff75b4076e3479d9e291b75a5a2f2bcb","modified":1758252604937},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1758252604938},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"04838b4b2ca4788700c48449e5fb6790d18c0f2e","modified":1758252604939},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1758252604938},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"403c39c7bb1caa1f3b142207b59aa0567f898a31","modified":1758252604939},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"1fb15f13ba70d5b954f62920c6b63d26e2fb2985","modified":1758252604940},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"4132e25ba9680c4b911a01abc75f501cda3fa4f1","modified":1758252604940},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1758252604939},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"8d971a00e644a600179b04815688d188f094012e","modified":1758252604940},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1758252604940},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1758252604941},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"fd5d3187f4e3d45f8af08f93b263fca7ed666c75","modified":1758252604931},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.min.js","hash":"eef46b6fb2e460838cd7328a6e13ecda0cb1e194","modified":1758252604945},{"_id":"themes/landscape/source/js/jquery-3.6.4.min.js","hash":"edf8a6a066f201b1ffad32c585bd79c9982d4433","modified":1758252604946},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1758252604944},{"_id":"public/2025/09/19/hello-world/index.html","hash":"2eec626a8a4410c81d47d23006a0d7916be63ba8","modified":1758293095921},{"_id":"public/archives/index.html","hash":"e6442ec2f445804f2047f305d913a04f19cbbe7c","modified":1758293095921},{"_id":"public/archives/2025/index.html","hash":"a1c7858974a4dce4dd0c5e34093cad7203a82094","modified":1758293095921},{"_id":"public/archives/2025/09/index.html","hash":"2e8e0e6c71aa82755bedeefb8e0aa2b985141828","modified":1758293095921},{"_id":"public/categories/æ—¥è®°/index.html","hash":"8b6a76b5f677dbdd4d7eb8bdc2827c379a1faa6a","modified":1758293095921},{"_id":"public/index.html","hash":"5c87511db40ccd6f12b95a57117dfccaf9da8b8b","modified":1758293095921},{"_id":"public/tags/Hexo/index.html","hash":"18fd9ee0af4294cf5a86a9033438c3d680d66da4","modified":1758293095921},{"_id":"public/tags/åšå®¢/index.html","hash":"c76b653363a8381081a655435a1b46a261807dda","modified":1758252791634},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1758293095921},{"_id":"public/js/jquery-3.6.4.min.js","hash":"eda46747c71d38a880bee44f9a439c3858bb8f99","modified":1758293095921},{"_id":"public/css/style.css","hash":"ecc329be740a220cc188ff49b02da4847cb7ee5e","modified":1758293095921},{"_id":"public/js/script.js","hash":"49773efcb2221bbdf2d86f3f5c5ff2d841b528cc","modified":1758293095921},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1758293095921},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1758293095921},{"_id":"public/tags/Java/index.html","hash":"9c4aa33a83a03e45c5fc28f392598a38e7b10fae","modified":1758293095921},{"_id":"public/tags/Python/index.html","hash":"fc7b25eea840c974388354cfe18704e3c471e926","modified":1758252791634},{"_id":"public/tags/AI/index.html","hash":"5d7cb0f203c67a1b2e3dd28b5df6352aa4cb0185","modified":1758252791634},{"_id":"source/_posts/RocketMQå»¶æ—¶MQçš„åŸç†é˜…è¯».md","hash":"027f945f738ad21d7e7107f4e0f38931b7b7f316","modified":1758690519469},{"_id":"source/_drafts/todo-list.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1758349173310},{"_id":"public/2025/09/19/RocketMQå»¶æ—¶MQçš„åŸç†é˜…è¯»/index.html","hash":"f7d85b102e07ec8428eaa50a017804b81b1d0e2a","modified":1758293095921},{"_id":"public/tags/RocketMQ/index.html","hash":"0949bc29f15faa862ea67d22fce7158972e56e1f","modified":1758293095921},{"_id":"public/tags/åˆ†å¸ƒå¼/index.html","hash":"5acd8f5e0fe34595828a27fb3f0e99bb19d3e79f","modified":1758293095921},{"_id":"public/tags/æ¶æ„/index.html","hash":"b7654074ca88eaa169714b57ff23f3e07c64a41c","modified":1758293095921},{"_id":"public/tags/æ¶ˆæ¯é˜Ÿåˆ—/index.html","hash":"1fb88f6532d8e891f164968082d0b15c0898f584","modified":1758293095921},{"_id":"public/tags/æºç /index.html","hash":"de866d0d136c64b09ace2e6ebccb1126614b8639","modified":1758293095921},{"_id":"public/categories/æŠ€æœ¯åˆ†äº«/å­¦ä¹ è®°å½•/index.html","hash":"5955dae408dea05f7efac0adb7b27e16ef1f8c6c","modified":1758293095921},{"_id":"public/categories/æŠ€æœ¯åˆ†äº«/index.html","hash":"b47a1d319a49d503effd8d97307cb8477c86e748","modified":1758293095921}],"Category":[{"name":"æ—¥è®°","_id":"cmfqa7j9q0001k4u7dcu13wqm"},{"name":"æŠ€æœ¯åˆ†äº«","_id":"cmfqf6qtl0001kgu7gr5da4wd"},{"name":"å­¦ä¹ è®°å½•","parent":"cmfqf6qtl0001kgu7gr5da4wd","_id":"cmfqf6qtn0004kgu77vo0bvzo"}],"Data":[],"Page":[],"Post":[{"title":"Hello World","date":"2025-09-19T03:30:00.000Z","_content":"\næ¬¢è¿æ¥åˆ°æˆ‘çš„å…¨æ–°Hexoåšå®¢ï¼\n\nè¿™æ˜¯ä¸€ä¸ªå…¨æ–°å¼€å§‹çš„æŠ€æœ¯åšå®¢ï¼Œæˆ‘å°†åœ¨è¿™é‡Œåˆ†äº«ï¼š\n\n## ä¸»è¦å†…å®¹\n\n- **Javaå¼€å‘** - æºç åˆ†æã€Springç”Ÿæ€ã€å¾®æœåŠ¡æ¶æ„ã€JVMè°ƒä¼˜\n- **Pythonç¼–ç¨‹** - åŸºç¡€è¯­æ³•ã€æ•°æ®åˆ†æã€æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ æ¡†æ¶\n- **ç½‘ç»œå®‰å…¨** - å…¥ä¾µæ£€æµ‹ã€å®‰å…¨é˜²æŠ¤ã€æ¸—é€æµ‹è¯•ã€å®‰å…¨æ¶æ„è®¾è®¡\n- **åˆ†å¸ƒå¼ç³»ç»Ÿ** - å¾®æœåŠ¡æ¶æ„ã€æœåŠ¡æ²»ç†ã€åˆ†å¸ƒå¼äº‹åŠ¡ã€é«˜å¯ç”¨è®¾è®¡\n- **ç³»ç»Ÿæ¶æ„** - æ¶æ„è®¾è®¡æ¨¡å¼ã€æ€§èƒ½ä¼˜åŒ–ã€å®¹å™¨åŒ–éƒ¨ç½²ã€äº‘åŸç”Ÿ\n- **äººå·¥æ™ºèƒ½** - æœºå™¨å­¦ä¹ ç®—æ³•ã€æ·±åº¦å­¦ä¹ ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€è®¡ç®—æœºè§†è§‰\n- **æ•°æ®åº“æŠ€æœ¯** - SQLä¼˜åŒ–ã€NoSQLã€åˆ†å¸ƒå¼æ•°æ®åº“ã€æ•°æ®ä»“åº“\n- **å¼€å‘å·¥å…·** - Gitä½¿ç”¨ã€IDEé…ç½®ã€CI/CDã€DevOpså®è·µ\n\n## åšå®¢ç‰¹è‰²\n\nâœ¨ **æŠ€æœ¯æ·±åº¦** - ä¸ä»…ä»…æ˜¯ä½¿ç”¨ï¼Œæ›´æ³¨é‡åŸç†ç†è§£å’Œæºç åˆ†æ  \nğŸš€ **å®æˆ˜å¯¼å‘** - ç»“åˆå®é™…é¡¹ç›®ç»éªŒï¼Œåˆ†äº«æ¶æ„è®¾è®¡å’Œè§£å†³æ–¹æ¡ˆ  \nğŸ“š **æŒç»­å­¦ä¹ ** - è®°å½•å­¦ä¹ è¿‡ç¨‹ï¼Œåˆ†äº«å‰æ²¿æŠ€æœ¯è¶‹åŠ¿  \nğŸ”§ **å·¥å…·åˆ†äº«** - æ¨èå¥½ç”¨çš„å¼€å‘å·¥å…·å’Œæœ€ä½³å®è·µ  \nğŸ—ï¸ **æ¶æ„æ€ç»´** - ä»å•ä½“åˆ°å¾®æœåŠ¡ï¼Œä»ä¼ ç»Ÿåˆ°äº‘åŸç”Ÿçš„æ¶æ„æ¼”è¿›  \nğŸ¤– **AIæ¢ç´¢** - äººå·¥æ™ºèƒ½åœ¨å®é™…ä¸šåŠ¡ä¸­çš„åº”ç”¨å’Œå®è·µ  \n\n## è”ç³»æ–¹å¼\n\nå¦‚æœä½ å¯¹æ–‡ç« å†…å®¹æœ‰ä»»ä½•ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»æˆ‘ï¼š\n\n- GitHub: [JathonKatu](https://github.com/JathonKatu)\n- Email: jathonkatu@foxmail.com\n\nè®©æˆ‘ä»¬ä¸€èµ·åœ¨æŠ€æœ¯çš„é“è·¯ä¸Šä¸æ–­å‰è¿›ï¼ğŸ¯","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2025-09-19 11:30:00\ntags: [Hexo] \ncategories: [æ—¥è®°]\n---\n\næ¬¢è¿æ¥åˆ°æˆ‘çš„å…¨æ–°Hexoåšå®¢ï¼\n\nè¿™æ˜¯ä¸€ä¸ªå…¨æ–°å¼€å§‹çš„æŠ€æœ¯åšå®¢ï¼Œæˆ‘å°†åœ¨è¿™é‡Œåˆ†äº«ï¼š\n\n## ä¸»è¦å†…å®¹\n\n- **Javaå¼€å‘** - æºç åˆ†æã€Springç”Ÿæ€ã€å¾®æœåŠ¡æ¶æ„ã€JVMè°ƒä¼˜\n- **Pythonç¼–ç¨‹** - åŸºç¡€è¯­æ³•ã€æ•°æ®åˆ†æã€æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ æ¡†æ¶\n- **ç½‘ç»œå®‰å…¨** - å…¥ä¾µæ£€æµ‹ã€å®‰å…¨é˜²æŠ¤ã€æ¸—é€æµ‹è¯•ã€å®‰å…¨æ¶æ„è®¾è®¡\n- **åˆ†å¸ƒå¼ç³»ç»Ÿ** - å¾®æœåŠ¡æ¶æ„ã€æœåŠ¡æ²»ç†ã€åˆ†å¸ƒå¼äº‹åŠ¡ã€é«˜å¯ç”¨è®¾è®¡\n- **ç³»ç»Ÿæ¶æ„** - æ¶æ„è®¾è®¡æ¨¡å¼ã€æ€§èƒ½ä¼˜åŒ–ã€å®¹å™¨åŒ–éƒ¨ç½²ã€äº‘åŸç”Ÿ\n- **äººå·¥æ™ºèƒ½** - æœºå™¨å­¦ä¹ ç®—æ³•ã€æ·±åº¦å­¦ä¹ ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€è®¡ç®—æœºè§†è§‰\n- **æ•°æ®åº“æŠ€æœ¯** - SQLä¼˜åŒ–ã€NoSQLã€åˆ†å¸ƒå¼æ•°æ®åº“ã€æ•°æ®ä»“åº“\n- **å¼€å‘å·¥å…·** - Gitä½¿ç”¨ã€IDEé…ç½®ã€CI/CDã€DevOpså®è·µ\n\n## åšå®¢ç‰¹è‰²\n\nâœ¨ **æŠ€æœ¯æ·±åº¦** - ä¸ä»…ä»…æ˜¯ä½¿ç”¨ï¼Œæ›´æ³¨é‡åŸç†ç†è§£å’Œæºç åˆ†æ  \nğŸš€ **å®æˆ˜å¯¼å‘** - ç»“åˆå®é™…é¡¹ç›®ç»éªŒï¼Œåˆ†äº«æ¶æ„è®¾è®¡å’Œè§£å†³æ–¹æ¡ˆ  \nğŸ“š **æŒç»­å­¦ä¹ ** - è®°å½•å­¦ä¹ è¿‡ç¨‹ï¼Œåˆ†äº«å‰æ²¿æŠ€æœ¯è¶‹åŠ¿  \nğŸ”§ **å·¥å…·åˆ†äº«** - æ¨èå¥½ç”¨çš„å¼€å‘å·¥å…·å’Œæœ€ä½³å®è·µ  \nğŸ—ï¸ **æ¶æ„æ€ç»´** - ä»å•ä½“åˆ°å¾®æœåŠ¡ï¼Œä»ä¼ ç»Ÿåˆ°äº‘åŸç”Ÿçš„æ¶æ„æ¼”è¿›  \nğŸ¤– **AIæ¢ç´¢** - äººå·¥æ™ºèƒ½åœ¨å®é™…ä¸šåŠ¡ä¸­çš„åº”ç”¨å’Œå®è·µ  \n\n## è”ç³»æ–¹å¼\n\nå¦‚æœä½ å¯¹æ–‡ç« å†…å®¹æœ‰ä»»ä½•ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»æˆ‘ï¼š\n\n- GitHub: [JathonKatu](https://github.com/JathonKatu)\n- Email: jathonkatu@foxmail.com\n\nè®©æˆ‘ä»¬ä¸€èµ·åœ¨æŠ€æœ¯çš„é“è·¯ä¸Šä¸æ–­å‰è¿›ï¼ğŸ¯","slug":"hello-world","published":1,"updated":"2025-09-20T06:18:05.581Z","_id":"cmfqa7j9n0000k4u7eg5zauep","comments":1,"layout":"post","photos":[],"content":"<p>æ¬¢è¿æ¥åˆ°æˆ‘çš„å…¨æ–°Hexoåšå®¢ï¼</p>\n<p>è¿™æ˜¯ä¸€ä¸ªå…¨æ–°å¼€å§‹çš„æŠ€æœ¯åšå®¢ï¼Œæˆ‘å°†åœ¨è¿™é‡Œåˆ†äº«ï¼š</p>\n<h2 id=\"ä¸»è¦å†…å®¹\"><a href=\"#ä¸»è¦å†…å®¹\" class=\"headerlink\" title=\"ä¸»è¦å†…å®¹\"></a>ä¸»è¦å†…å®¹</h2><ul>\n<li><strong>Javaå¼€å‘</strong> - æºç åˆ†æã€Springç”Ÿæ€ã€å¾®æœåŠ¡æ¶æ„ã€JVMè°ƒä¼˜</li>\n<li><strong>Pythonç¼–ç¨‹</strong> - åŸºç¡€è¯­æ³•ã€æ•°æ®åˆ†æã€æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ æ¡†æ¶</li>\n<li><strong>ç½‘ç»œå®‰å…¨</strong> - å…¥ä¾µæ£€æµ‹ã€å®‰å…¨é˜²æŠ¤ã€æ¸—é€æµ‹è¯•ã€å®‰å…¨æ¶æ„è®¾è®¡</li>\n<li><strong>åˆ†å¸ƒå¼ç³»ç»Ÿ</strong> - å¾®æœåŠ¡æ¶æ„ã€æœåŠ¡æ²»ç†ã€åˆ†å¸ƒå¼äº‹åŠ¡ã€é«˜å¯ç”¨è®¾è®¡</li>\n<li><strong>ç³»ç»Ÿæ¶æ„</strong> - æ¶æ„è®¾è®¡æ¨¡å¼ã€æ€§èƒ½ä¼˜åŒ–ã€å®¹å™¨åŒ–éƒ¨ç½²ã€äº‘åŸç”Ÿ</li>\n<li><strong>äººå·¥æ™ºèƒ½</strong> - æœºå™¨å­¦ä¹ ç®—æ³•ã€æ·±åº¦å­¦ä¹ ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€è®¡ç®—æœºè§†è§‰</li>\n<li><strong>æ•°æ®åº“æŠ€æœ¯</strong> - SQLä¼˜åŒ–ã€NoSQLã€åˆ†å¸ƒå¼æ•°æ®åº“ã€æ•°æ®ä»“åº“</li>\n<li><strong>å¼€å‘å·¥å…·</strong> - Gitä½¿ç”¨ã€IDEé…ç½®ã€CI&#x2F;CDã€DevOpså®è·µ</li>\n</ul>\n<h2 id=\"åšå®¢ç‰¹è‰²\"><a href=\"#åšå®¢ç‰¹è‰²\" class=\"headerlink\" title=\"åšå®¢ç‰¹è‰²\"></a>åšå®¢ç‰¹è‰²</h2><p>âœ¨ <strong>æŠ€æœ¯æ·±åº¦</strong> - ä¸ä»…ä»…æ˜¯ä½¿ç”¨ï¼Œæ›´æ³¨é‡åŸç†ç†è§£å’Œæºç åˆ†æ<br>ğŸš€ <strong>å®æˆ˜å¯¼å‘</strong> - ç»“åˆå®é™…é¡¹ç›®ç»éªŒï¼Œåˆ†äº«æ¶æ„è®¾è®¡å’Œè§£å†³æ–¹æ¡ˆ<br>ğŸ“š <strong>æŒç»­å­¦ä¹ </strong> - è®°å½•å­¦ä¹ è¿‡ç¨‹ï¼Œåˆ†äº«å‰æ²¿æŠ€æœ¯è¶‹åŠ¿<br>ğŸ”§ <strong>å·¥å…·åˆ†äº«</strong> - æ¨èå¥½ç”¨çš„å¼€å‘å·¥å…·å’Œæœ€ä½³å®è·µ<br>ğŸ—ï¸ <strong>æ¶æ„æ€ç»´</strong> - ä»å•ä½“åˆ°å¾®æœåŠ¡ï¼Œä»ä¼ ç»Ÿåˆ°äº‘åŸç”Ÿçš„æ¶æ„æ¼”è¿›<br>ğŸ¤– <strong>AIæ¢ç´¢</strong> - äººå·¥æ™ºèƒ½åœ¨å®é™…ä¸šåŠ¡ä¸­çš„åº”ç”¨å’Œå®è·µ  </p>\n<h2 id=\"è”ç³»æ–¹å¼\"><a href=\"#è”ç³»æ–¹å¼\" class=\"headerlink\" title=\"è”ç³»æ–¹å¼\"></a>è”ç³»æ–¹å¼</h2><p>å¦‚æœä½ å¯¹æ–‡ç« å†…å®¹æœ‰ä»»ä½•ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»æˆ‘ï¼š</p>\n<ul>\n<li>GitHub: <a href=\"https://github.com/JathonKatu\">JathonKatu</a></li>\n<li>Email: <a href=\"mailto:&#x6a;&#97;&#x74;&#x68;&#111;&#110;&#107;&#97;&#x74;&#x75;&#64;&#102;&#111;&#x78;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\">jathonkatu@foxmail.com</a></li>\n</ul>\n<p>è®©æˆ‘ä»¬ä¸€èµ·åœ¨æŠ€æœ¯çš„é“è·¯ä¸Šä¸æ–­å‰è¿›ï¼ğŸ¯</p>\n","excerpt":"","more":"<p>æ¬¢è¿æ¥åˆ°æˆ‘çš„å…¨æ–°Hexoåšå®¢ï¼</p>\n<p>è¿™æ˜¯ä¸€ä¸ªå…¨æ–°å¼€å§‹çš„æŠ€æœ¯åšå®¢ï¼Œæˆ‘å°†åœ¨è¿™é‡Œåˆ†äº«ï¼š</p>\n<h2 id=\"ä¸»è¦å†…å®¹\"><a href=\"#ä¸»è¦å†…å®¹\" class=\"headerlink\" title=\"ä¸»è¦å†…å®¹\"></a>ä¸»è¦å†…å®¹</h2><ul>\n<li><strong>Javaå¼€å‘</strong> - æºç åˆ†æã€Springç”Ÿæ€ã€å¾®æœåŠ¡æ¶æ„ã€JVMè°ƒä¼˜</li>\n<li><strong>Pythonç¼–ç¨‹</strong> - åŸºç¡€è¯­æ³•ã€æ•°æ®åˆ†æã€æœºå™¨å­¦ä¹ ã€æ·±åº¦å­¦ä¹ æ¡†æ¶</li>\n<li><strong>ç½‘ç»œå®‰å…¨</strong> - å…¥ä¾µæ£€æµ‹ã€å®‰å…¨é˜²æŠ¤ã€æ¸—é€æµ‹è¯•ã€å®‰å…¨æ¶æ„è®¾è®¡</li>\n<li><strong>åˆ†å¸ƒå¼ç³»ç»Ÿ</strong> - å¾®æœåŠ¡æ¶æ„ã€æœåŠ¡æ²»ç†ã€åˆ†å¸ƒå¼äº‹åŠ¡ã€é«˜å¯ç”¨è®¾è®¡</li>\n<li><strong>ç³»ç»Ÿæ¶æ„</strong> - æ¶æ„è®¾è®¡æ¨¡å¼ã€æ€§èƒ½ä¼˜åŒ–ã€å®¹å™¨åŒ–éƒ¨ç½²ã€äº‘åŸç”Ÿ</li>\n<li><strong>äººå·¥æ™ºèƒ½</strong> - æœºå™¨å­¦ä¹ ç®—æ³•ã€æ·±åº¦å­¦ä¹ ã€è‡ªç„¶è¯­è¨€å¤„ç†ã€è®¡ç®—æœºè§†è§‰</li>\n<li><strong>æ•°æ®åº“æŠ€æœ¯</strong> - SQLä¼˜åŒ–ã€NoSQLã€åˆ†å¸ƒå¼æ•°æ®åº“ã€æ•°æ®ä»“åº“</li>\n<li><strong>å¼€å‘å·¥å…·</strong> - Gitä½¿ç”¨ã€IDEé…ç½®ã€CI&#x2F;CDã€DevOpså®è·µ</li>\n</ul>\n<h2 id=\"åšå®¢ç‰¹è‰²\"><a href=\"#åšå®¢ç‰¹è‰²\" class=\"headerlink\" title=\"åšå®¢ç‰¹è‰²\"></a>åšå®¢ç‰¹è‰²</h2><p>âœ¨ <strong>æŠ€æœ¯æ·±åº¦</strong> - ä¸ä»…ä»…æ˜¯ä½¿ç”¨ï¼Œæ›´æ³¨é‡åŸç†ç†è§£å’Œæºç åˆ†æ<br>ğŸš€ <strong>å®æˆ˜å¯¼å‘</strong> - ç»“åˆå®é™…é¡¹ç›®ç»éªŒï¼Œåˆ†äº«æ¶æ„è®¾è®¡å’Œè§£å†³æ–¹æ¡ˆ<br>ğŸ“š <strong>æŒç»­å­¦ä¹ </strong> - è®°å½•å­¦ä¹ è¿‡ç¨‹ï¼Œåˆ†äº«å‰æ²¿æŠ€æœ¯è¶‹åŠ¿<br>ğŸ”§ <strong>å·¥å…·åˆ†äº«</strong> - æ¨èå¥½ç”¨çš„å¼€å‘å·¥å…·å’Œæœ€ä½³å®è·µ<br>ğŸ—ï¸ <strong>æ¶æ„æ€ç»´</strong> - ä»å•ä½“åˆ°å¾®æœåŠ¡ï¼Œä»ä¼ ç»Ÿåˆ°äº‘åŸç”Ÿçš„æ¶æ„æ¼”è¿›<br>ğŸ¤– <strong>AIæ¢ç´¢</strong> - äººå·¥æ™ºèƒ½åœ¨å®é™…ä¸šåŠ¡ä¸­çš„åº”ç”¨å’Œå®è·µ  </p>\n<h2 id=\"è”ç³»æ–¹å¼\"><a href=\"#è”ç³»æ–¹å¼\" class=\"headerlink\" title=\"è”ç³»æ–¹å¼\"></a>è”ç³»æ–¹å¼</h2><p>å¦‚æœä½ å¯¹æ–‡ç« å†…å®¹æœ‰ä»»ä½•ç–‘é—®æˆ–å»ºè®®ï¼Œæ¬¢è¿é€šè¿‡ä»¥ä¸‹æ–¹å¼è”ç³»æˆ‘ï¼š</p>\n<ul>\n<li>GitHub: <a href=\"https://github.com/JathonKatu\">JathonKatu</a></li>\n<li>Email: <a href=\"mailto:&#x6a;&#97;&#x74;&#x68;&#111;&#110;&#107;&#97;&#x74;&#x75;&#64;&#102;&#111;&#x78;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\">jathonkatu@foxmail.com</a></li>\n</ul>\n<p>è®©æˆ‘ä»¬ä¸€èµ·åœ¨æŠ€æœ¯çš„é“è·¯ä¸Šä¸æ–­å‰è¿›ï¼ğŸ¯</p>\n"},{"title":"RocketMQå»¶æ—¶MQçš„åŸç†é˜…è¯»","date":"2025-09-19T04:30:00.000Z","_content":"status: draft\ncreateDate: 2025-09-19 11:44:41\nendDate:\n\n## ç›®å½•\n### [RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸](#rocketmq-4.x-now)\n### RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\n### RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\n### RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\n### RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\n### RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\n### å†™åœ¨æœ€å\n\n## RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£<a id=\"rocketmq-4.x-now\"></a>\nå­—æ®µmessage.delayTimeLevel\næšä¸¾ä¸ºæ•°å­—1-18ï¼Œåªæ”¯æŒ18ä¸ªå›ºå®šå»¶æ—¶ç­‰çº§ï¼ˆ1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2hï¼‰\nRocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æ\nåº•å±‚å®ç°ä¸»è¦æ˜¯åŸºäºBrokeç«¯ï¼Œä¸»è¦æ¶‰åŠä»¥ä¸‹ç»„ä»¶ï¼š\n\n1. CommitLog å†™å…¥å¤„\nå½“æ¶ˆæ¯å¸¦æœ‰delayTimeLevel > 0æ—¶ï¼Œåœ¨CommitLog#asyncPutMessageæ–¹æ³•ä¸­ä¼šè¿›è¡Œç‰¹æ®Šå¤„ç†(è€ç‰ˆæœ¬æ˜¯CommitLog#putMessage)\n- å°†åŸå§‹çš„topicå’ŒqueueIdä¿å­˜åˆ°æ¶ˆæ¯å±æ€§ä¸­(REAL_TOPICã€REAL_QUEUE_ID)\n- ä¿®æ”¹æ¶ˆæ¯çš„topicä¸ºç³»ç»Ÿé¢„è®¾çš„å»¶è¿Ÿtopic(SCHEDULE_TOPIC_XXXX)\n- æ ¹æ®å»¶è¿Ÿçº§åˆ«è®¡ç®—å‡ºå¯¹åº”çš„queueId ScheduleMessageService#delayLevel2QueueIdå¹¶æŠ•æ”¾åˆ°å¯¹åº”çš„queueä¸­\n2. å®šæ—¶è°ƒåº¦æœåŠ¡ScheduleMessageService\nè¯¥æœåŠ¡è´Ÿè´£æ‰«æå»¶è¿Ÿé˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ï¼Œå¹¶åœ¨åˆ°æœŸåå°†å…¶é‡æ–°æŠ•é€’åˆ°åŸå§‹çš„topic\nå¯åŠ¨æ—¶ä¸ºæ¯ä¸€ä¸ªå»¶è¿Ÿçº§åˆ«çš„queueåˆ›å»ºä¸€ä¸ªå®šæ—¶ä»»åŠ¡\nå®šæœŸæ£€æŸ¥æ¯ä¸ªå»¶è¿Ÿé˜Ÿåˆ—çš„æ¶ˆæ¯æ˜¯å¦åˆ°æœŸ(ä¸Šä¸€æ­¥ä¼šè®¡ç®—å½“å‰æ—¶é—´ï¼Œå¹¶æ ¹æ®å»¶è¿Ÿç­‰çº§è®¡ç®—å‡ºåˆ°æœŸæ—¶é—´ï¼Œæ³¨æ„è¶…å‡º18ä¼šé»˜è®¤18)\nåˆ°æœŸåï¼Œæ¢å¤åŸå§‹topicå’ŒqueueIdï¼Œé‡æ–°æ„å»ºæ¶ˆæ¯å¹¶å†™å…¥CommitLogï¼Œè¿›å…¥æ­£å¸¸æ¶ˆè´¹æµç¨‹ã€‚\nå…³é”®æºç \norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest\norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage\norg.apache.rocketmq.store.CommitLog#asyncPutMessage\norg.apache.rocketmq.store.schedule.ScheduleMessageService#start\norg.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask\nRocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æ\norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest\né¦–å…ˆæ˜¯æ”¶åˆ°çš„æ¶ˆæ¯å…ˆé€šè¿‡è¿™ä¸ªæ–¹æ³•è¿›è¡Œè½¬å‘å¤„ç†ï¼Œä¸»è¦æ˜¯ç¬¬17è¡Œä»£ç æä¾›å…¥å£ã€‚\n\npublic CompletableFuture<RemotingCommand> asyncProcessRequest(ChannelHandlerContext ctx,\n                                                                  RemotingCommand request) throws RemotingCommandException {\n        final SendMessageContext mqtraceContext;\n        switch (request.getCode()) {\n            case RequestCode.CONSUMER_SEND_MSG_BACK:\n                return this.asyncConsumerSendMsgBack(ctx, request);\n            default:\n                SendMessageRequestHeader requestHeader = parseRequestHeader(request);\n                if (requestHeader == null) {\n                    return CompletableFuture.completedFuture(null);\n                }\n                mqtraceContext = buildMsgContext(ctx, requestHeader);\n                this.executeSendMessageHookBefore(ctx, request, mqtraceContext);\n                if (requestHeader.isBatch()) {\n                    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);\n                } else {\n                    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);\n                }\n        }\n    }\norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage\nè¿™é‡Œä¸»è¦çš„æ˜¯å…³æ³¨ç¬¬61è¡Œä»£ç ï¼Œè¿›å…¥åˆ°Stroreï¼Œè¿è¡ŒasyncPutMessageã€‚\n\nprivate CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                                SendMessageContext mqtraceContext,\n                                                                SendMessageRequestHeader requestHeader) {\n        final RemotingCommand response = preSend(ctx, request, requestHeader);\n        final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();\n\n        if (response.getCode() != -1) {\n            return CompletableFuture.completedFuture(response);\n        }\n\n        final byte[] body = request.getBody();\n\n        int queueIdInt = requestHeader.getQueueId();\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n\n        if (queueIdInt < 0) {\n            queueIdInt = randomQueueId(topicConfig.getWriteQueueNums());\n        }\n\n        MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n        msgInner.setTopic(requestHeader.getTopic());\n        msgInner.setQueueId(queueIdInt);\n\n        if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) {\n            return CompletableFuture.completedFuture(response);\n        }\n\n        msgInner.setBody(body);\n        msgInner.setFlag(requestHeader.getFlag());\n        Map<String, String> origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n        MessageAccessor.setProperties(msgInner, origProps);\n        msgInner.setBornTimestamp(requestHeader.getBornTimestamp());\n        msgInner.setBornHost(ctx.channel().remoteAddress());\n        msgInner.setStoreHost(this.getStoreHost());\n        msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());\n        String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName();\n        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);\n        if (origProps.containsKey(MessageConst.PROPERTY_WAIT_STORE_MSG_OK)) {\n            // There is no need to store \"WAIT=true\", remove it from propertiesString to save 9 bytes for each message.\n            // It works for most case. In some cases msgInner.setPropertiesString invoked later and replace it.\n            String waitStoreMsgOKValue = origProps.remove(MessageConst.PROPERTY_WAIT_STORE_MSG_OK);\n            msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n            // Reput to properties, since msgInner.isWaitStoreMsgOK() will be invoked later\n            origProps.put(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, waitStoreMsgOKValue);\n        } else {\n            msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n        }\n\n        CompletableFuture<PutMessageResult> putMessageResult = null;\n        String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n        if (Boolean.parseBoolean(transFlag)) {\n            if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n                response.setCode(ResponseCode.NO_PERMISSION);\n                response.setRemark(\n                        \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n                                + \"] sending transaction message is forbidden\");\n                return CompletableFuture.completedFuture(response);\n            }\n            putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n        } else {\n            putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n        }\n        return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n    }\norg.apache.rocketmq.store.CommitLog#asyncPutMessage\nputMessageçš„è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä¸»è¦çœ‹ç¬¬åå…«è¡Œå¼€å§‹ï¼Œå¦‚æœæ˜¯å»¶è¿Ÿmqï¼Œåˆ™ä¼šå°†æ¶ˆæ¯æ”¾å…¥åˆ°topic=SCHEDULE_TOPIC_XXXX,queueId=delayLevel-1ä¸­\n\npublic CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n        // Set the storage time\n        msg.setStoreTimestamp(System.currentTimeMillis());\n        // Set the message body BODY CRC (consider the most appropriate setting\n        // on the client)\n        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));\n        // Back to Results\n        AppendMessageResult result = null;\n\n        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n\n        String topic = msg.getTopic();\n//        int queueId msg.getQueueId();\n        final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());\n        if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE\n                || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n            // Delay Delivery\n            if (msg.getDelayTimeLevel() > 0) {\n                if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n                }\n\n                topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n                int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n                // Backup real topic, queueId\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\n                msg.setTopic(topic);\n                msg.setQueueId(queueId);\n            }\n        }\n\n        InetSocketAddress bornSocketAddress = (InetSocketAddress) msg.getBornHost();\n        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n            msg.setBornHostV6Flag();\n        }\n\n        InetSocketAddress storeSocketAddress = (InetSocketAddress) msg.getStoreHost();\n        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n            msg.setStoreHostAddressV6Flag();\n        }\n\n        PutMessageThreadLocal putMessageThreadLocal = this.putMessageThreadLocal.get();\n        updateMaxMessageSize(putMessageThreadLocal);\n        if (!multiDispatch.isMultiDispatchMsg(msg)) {\n            PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);\n            if (encodeResult != null) {\n                return CompletableFuture.completedFuture(encodeResult);\n            }\n            msg.setEncodedBuff(putMessageThreadLocal.getEncoder().getEncoderBuffer());\n        }\n        PutMessageContext putMessageContext = new PutMessageContext(generateKey(putMessageThreadLocal.getKeyBuilder(), msg));\n\n        long elapsedTimeInLock = 0;\n        MappedFile unlockMappedFile = null;\n\n        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n        try {\n            MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n            long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();\n            this.beginTimeInLock = beginLockTimestamp;\n\n            // Here settings are stored timestamp, in order to ensure an orderly\n            // global\n            msg.setStoreTimestamp(beginLockTimestamp);\n\n            if (null == mappedFile || mappedFile.isFull()) {\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n            }\n            if (null == mappedFile) {\n                log.error(\"create mapped file1 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n            }\n\n            result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n            switch (result.getStatus()) {\n                case PUT_OK:\n                    break;\n                case END_OF_FILE:\n                    unlockMappedFile = mappedFile;\n                    // Create a new file, re-write the message\n                    mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                    if (null == mappedFile) {\n                        // XXX: warn and notify me\n                        log.error(\"create mapped file2 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n                        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                    }\n                    result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n                    break;\n                case MESSAGE_SIZE_EXCEEDED:\n                case PROPERTIES_SIZE_EXCEEDED:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n                case UNKNOWN_ERROR:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n                default:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            }\n\n            elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n        } finally {\n            beginTimeInLock = 0;\n            putMessageLock.unlock();\n        }\n\n        if (elapsedTimeInLock > 500) {\n            log.warn(\"[NOTIFYME]putMessage in lock cost time(ms)={}, bodyLength={} AppendMessageResult={}\", elapsedTimeInLock, msg.getBody().length, result);\n        }\n\n        if (null != unlockMappedFile && this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {\n            this.defaultMessageStore.unlockMappedFile(unlockMappedFile);\n        }\n\n        PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);\n\n        // Statistics\n        storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).add(1);\n        storeStatsService.getSinglePutMessageTopicSizeTotal(topic).add(result.getWroteBytes());\n\n        CompletableFuture<PutMessageStatus> flushResultFuture = submitFlushRequest(result, msg);\n        CompletableFuture<PutMessageStatus> replicaResultFuture = submitReplicaRequest(result, msg);\n        return flushResultFuture.thenCombine(replicaResultFuture, (flushStatus, replicaStatus) -> {\n            if (flushStatus != PutMessageStatus.PUT_OK) {\n                putMessageResult.setPutMessageStatus(flushStatus);\n            }\n            if (replicaStatus != PutMessageStatus.PUT_OK) {\n                putMessageResult.setPutMessageStatus(replicaStatus);\n            }\n            return putMessageResult;\n        });\n    }\norg.apache.rocketmq.store.schedule.ScheduleMessageService#start\nè¿™é‡Œä¸»è¦æ˜¯è§£é‡Šscheduleå¯¹æ¯ä¸€ä¸ªdelayLeveléƒ½å¯åŠ¨äº†ä¸€ä¸ªå®šæ—¶ä»»åŠ¡çº¿ç¨‹ï¼Œæ‰§è¡Œé¢‘ç‡æ ¹æ®ä¸åŒdelayLevelå¯¹åº”çš„deladeliveryTimeå†³å®šã€‚\n\npublic void start() {\n        if (started.compareAndSet(false, true)) {\n            this.load();\n            this.deliverExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageTimerThread_\"));\n            if (this.enableAsyncDeliver) {\n                this.handleExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageExecutorHandleThread_\"));\n            }\n            for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n                Integer level = entry.getKey();\n                Long timeDelay = entry.getValue();\n                Long offset = this.offsetTable.get(level);\n                if (null == offset) {\n                    offset = 0L;\n                }\n\n                if (timeDelay != null) {\n                    if (this.enableAsyncDeliver) {\n                        this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                    }\n                    this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                }\n            }\n\n            this.deliverExecutorService.scheduleAtFixedRate(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (started.get()) {\n                            ScheduleMessageService.this.persist();\n                        }\n                    } catch (Throwable e) {\n                        log.error(\"scheduleAtFixedRate flush exception\", e);\n                    }\n                }\n            }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n        }\n    }\norg.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask\ntaskä¸»è¦çš„ä»»åŠ¡å°±æ˜¯101è¡Œï¼Œè°ƒç”¨org.apache.rocketmq.store.schedule.ScheduleMessageService#messageTimeupï¼Œå°†å¯¹è±¡è½¬æ¢æˆMessageExtBrokerInnerå¯¹è±¡ï¼ˆå¹¶åœ¨æ­¤æ—¶å°†topicå’ŒqueueIdé‡ç½®æˆåŸæ¥çš„ï¼‰ï¼Œç„¶åè°ƒç”¨org.apache.rocketmq.store.DefaultMessageStore#putMessageï¼Œå°†æ¶ˆæ¯æ”¾å…¥åˆ°commitLogä¸­ã€‚\n\nclass DeliverDelayedMessageTimerTask implements Runnable {\n        private final int delayLevel;\n        private final long offset;\n\n        public DeliverDelayedMessageTimerTask(int delayLevel, long offset) {\n            this.delayLevel = delayLevel;\n            this.offset = offset;\n        }\n\n        @Override\n        public void run() {\n            try {\n                if (isStarted()) {\n                    this.executeOnTimeup();\n                }\n            } catch (Exception e) {\n                // XXX: warn and notify me\n                log.error(\"ScheduleMessageService, executeOnTimeup exception\", e);\n                this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);\n            }\n        }\n\n        /**\n         * @return\n         */\n        private long correctDeliverTimestamp(final long now, final long deliverTimestamp) {\n\n            long result = deliverTimestamp;\n\n            long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);\n            if (deliverTimestamp > maxTimestamp) {\n                result = now;\n            }\n\n            return result;\n        }\n\n        public void executeOnTimeup() {\n            ConsumeQueue cq =\n                ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC,\n                    delayLevel2QueueId(delayLevel));\n\n            if (cq == null) {\n                this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE);\n                return;\n            }\n\n            SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);\n            if (bufferCQ == null) {\n                long resetOffset;\n                if ((resetOffset = cq.getMinOffsetInQueue()) > this.offset) {\n                    log.error(\"schedule CQ offset invalid. offset={}, cqMinOffset={}, queueId={}\",\n                        this.offset, resetOffset, cq.getQueueId());\n                } else if ((resetOffset = cq.getMaxOffsetInQueue()) < this.offset) {\n                    log.error(\"schedule CQ offset invalid. offset={}, cqMaxOffset={}, queueId={}\",\n                        this.offset, resetOffset, cq.getQueueId());\n                } else {\n                    resetOffset = this.offset;\n                }\n\n                this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE);\n                return;\n            }\n\n            long nextOffset = this.offset;\n            try {\n                int i = 0;\n                ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();\n                for (; i < bufferCQ.getSize() && isStarted(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n                    long offsetPy = bufferCQ.getByteBuffer().getLong();\n                    int sizePy = bufferCQ.getByteBuffer().getInt();\n                    long tagsCode = bufferCQ.getByteBuffer().getLong();\n\n                    if (cq.isExtAddr(tagsCode)) {\n                        if (cq.getExt(tagsCode, cqExtUnit)) {\n                            tagsCode = cqExtUnit.getTagsCode();\n                        } else {\n                            //can't find ext content.So re compute tags code.\n                            log.error(\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}\",\n                                tagsCode, offsetPy, sizePy);\n                            long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);\n                            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);\n                        }\n                    }\n\n                    long now = System.currentTimeMillis();\n                    long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);\n                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n                    long countdown = deliverTimestamp - now;\n                    if (countdown > 0) {\n                        this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                        return;\n                    }\n\n                    MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);\n                    if (msgExt == null) {\n                        continue;\n                    }\n\n                    MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt);\n                    if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) {\n                        log.error(\"[BUG] the real topic of schedule msg is {}, discard the msg. msg={}\",\n                            msgInner.getTopic(), msgInner);\n                        continue;\n                    }\n\n                    boolean deliverSuc;\n                    if (ScheduleMessageService.this.enableAsyncDeliver) {\n                        deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                    } else {\n                        deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                    }\n\n                    if (!deliverSuc) {\n                        this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                        return;\n                    }\n                }\n\n                nextOffset = this.offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n            } catch (Exception e) {\n                log.error(\"ScheduleMessageService, messageTimeup execute error, offset = {}\", nextOffset, e);\n            } finally {\n                bufferCQ.release();\n            }\n\n            this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n        }\n\n        public void scheduleNextTimerTask(long offset, long delay) {\n            ScheduleMessageService.this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(\n                this.delayLevel, offset), delay, TimeUnit.MILLISECONDS);\n        }\n\n        private boolean syncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n            int sizePy) {\n            PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, false);\n            PutMessageResult result = resultProcess.get();\n            boolean sendStatus = result != null && result.getPutMessageStatus() == PutMessageStatus.PUT_OK;\n            if (sendStatus) {\n                ScheduleMessageService.this.updateOffset(this.delayLevel, resultProcess.getNextOffset());\n            }\n            return sendStatus;\n        }\n\n        private boolean asyncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n            int sizePy) {\n            Queue<PutResultProcess> processesQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel);\n\n            //Flow Control\n            int currentPendingNum = processesQueue.size();\n            int maxPendingLimit = ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig()\n                .getScheduleAsyncDeliverMaxPendingLimit();\n            if (currentPendingNum > maxPendingLimit) {\n                log.warn(\"Asynchronous deliver triggers flow control, \" +\n                    \"currentPendingNum={}, maxPendingLimit={}\", currentPendingNum, maxPendingLimit);\n                return false;\n            }\n\n            //Blocked\n            PutResultProcess firstProcess = processesQueue.peek();\n            if (firstProcess != null && firstProcess.need2Blocked()) {\n                log.warn(\"Asynchronous deliver block. info={}\", firstProcess.toString());\n                return false;\n            }\n\n            PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, true);\n            processesQueue.add(resultProcess);\n            return true;\n        }\n\n        private PutResultProcess deliverMessage(MessageExtBrokerInner msgInner, String msgId, long offset,\n            long offsetPy, int sizePy, boolean autoResend) {\n            CompletableFuture<PutMessageResult> future =\n                ScheduleMessageService.this.writeMessageStore.asyncPutMessage(msgInner);\n            return new PutResultProcess()\n                .setTopic(msgInner.getTopic())\n                .setDelayLevel(this.delayLevel)\n                .setOffset(offset)\n                .setPhysicOffset(offsetPy)\n                .setPhysicSize(sizePy)\n                .setMsgId(msgId)\n                .setAutoResend(autoResend)\n                .setFuture(future)\n                .thenProcess();\n        }\n    }\nRocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£\nå­—æ®µmessage.deliveryTimestamp\nå¯ä»¥é¢„å®šè§¦å‘çš„æ—¶é—´æˆ³ï¼Œè€Œä¸æ˜¯å»¶æ—¶æ—¶é•¿\næ”¯æŒä»¥æ ¼å¼ä¸ºæ¯«ç§’çº§unixæ—¶é—´æˆ³ï¼ˆé»˜è®¤1000æ¯«ç§’çš„ç²¾åº¦ä¹Ÿå°±æ˜¯1ç§’ï¼‰\næ”¯æŒæœ€é•¿24å°æ—¶ï¼Œä¸æ”¯æŒè‡ªå®šä¹‰ä¿®æ”¹ï¼Œè¶…è¿‡24å°æ—¶å»¶æ—¶ä¸ç”Ÿæ•ˆï¼ŒæœåŠ¡ç«¯ä¼šç«‹å³æŠ•é€’\nå®šæ—¶ä»»åŠ¡ä»…æ”¯æŒå‘é€åˆ°MessageTypeä¸ºDelayçš„Topicä¸­\nRocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æ\nRocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æ\nå†™åœ¨æœ€å\n     åœ¨2025å¹´09æœˆ18æ—¥ï¼Œå¿ƒè¡€æ¥æ½®åœ¨githubä¸Šæœç´¢rocketMQçš„å»¶è¿Ÿmqï¼Œå‘ç°äº†2018å¹´çš„ä¸€äº›ç‚¹ç‚¹æ»´æ»´ã€‚\n     æœ‰è‡ªå·±ä¸ºäº†å­¦ä¹ aiå¹¶ä½œä¸ºæ¯•è®¾çš„ä»“åº“ï¼Œæœ‰åŒå­¦å¸¦æˆ‘ç©çš„hexo + githubå®ç°çš„ç®€å•ä¸ªäººåšå®¢ã€‚\n     åœ¨çœ‹å®Œæ–‡æ¡£å’Œä»£ç ä¹‹åç™¾æ„Ÿäº¤é›†ï¼Œç»ˆäºæ‰“ç®—é‡æ–°å¼€å§‹å†™åšå®¢ã€‚ä¸çŸ¥é“è¿™æ¬¡è¿˜èƒ½åšæŒå¤šä¹…ï¼Œä½†æ˜¯æ—¢ç„¶è‡ªå·±èƒ½ä¸€å£æ°”å‡è‚¥æ‰äº†43æ–¤ï¼ˆæˆªè‡³ç›®å‰ï¼‰ï¼Œé‚£ä¹ˆè¿˜æœ‰ä»€ä¹ˆä¸èƒ½çš„å‘¢ï¼Ÿ\n     åŠ æ²¹å§è‡ªå·±ï¼Œåœ¨æ²¡æœ‰ç›®æ ‡çš„æ—¶å€™å¥½å¥½ç§¯ç´¯ï¼Œåšç§¯è–„å‘ã€‚","source":"_posts/RocketMQå»¶æ—¶MQçš„åŸç†é˜…è¯».md","raw":"---\ntitle: RocketMQå»¶æ—¶MQçš„åŸç†é˜…è¯»\ndate: 2025-09-19 12:30:00\ntags: [Java, RocketMQ, åˆ†å¸ƒå¼, æ¶ˆæ¯é˜Ÿåˆ—, æ¶æ„, æºç ] \ncategories: [æŠ€æœ¯åˆ†äº«, å­¦ä¹ è®°å½•]\n---\nstatus: draft\ncreateDate: 2025-09-19 11:44:41\nendDate:\n\n## ç›®å½•\n### [RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸](#rocketmq-4.x-now)\n### RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\n### RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\n### RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\n### RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\n### RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\n### å†™åœ¨æœ€å\n\n## RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£<a id=\"rocketmq-4.x-now\"></a>\nå­—æ®µmessage.delayTimeLevel\næšä¸¾ä¸ºæ•°å­—1-18ï¼Œåªæ”¯æŒ18ä¸ªå›ºå®šå»¶æ—¶ç­‰çº§ï¼ˆ1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2hï¼‰\nRocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æ\nåº•å±‚å®ç°ä¸»è¦æ˜¯åŸºäºBrokeç«¯ï¼Œä¸»è¦æ¶‰åŠä»¥ä¸‹ç»„ä»¶ï¼š\n\n1. CommitLog å†™å…¥å¤„\nå½“æ¶ˆæ¯å¸¦æœ‰delayTimeLevel > 0æ—¶ï¼Œåœ¨CommitLog#asyncPutMessageæ–¹æ³•ä¸­ä¼šè¿›è¡Œç‰¹æ®Šå¤„ç†(è€ç‰ˆæœ¬æ˜¯CommitLog#putMessage)\n- å°†åŸå§‹çš„topicå’ŒqueueIdä¿å­˜åˆ°æ¶ˆæ¯å±æ€§ä¸­(REAL_TOPICã€REAL_QUEUE_ID)\n- ä¿®æ”¹æ¶ˆæ¯çš„topicä¸ºç³»ç»Ÿé¢„è®¾çš„å»¶è¿Ÿtopic(SCHEDULE_TOPIC_XXXX)\n- æ ¹æ®å»¶è¿Ÿçº§åˆ«è®¡ç®—å‡ºå¯¹åº”çš„queueId ScheduleMessageService#delayLevel2QueueIdå¹¶æŠ•æ”¾åˆ°å¯¹åº”çš„queueä¸­\n2. å®šæ—¶è°ƒåº¦æœåŠ¡ScheduleMessageService\nè¯¥æœåŠ¡è´Ÿè´£æ‰«æå»¶è¿Ÿé˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ï¼Œå¹¶åœ¨åˆ°æœŸåå°†å…¶é‡æ–°æŠ•é€’åˆ°åŸå§‹çš„topic\nå¯åŠ¨æ—¶ä¸ºæ¯ä¸€ä¸ªå»¶è¿Ÿçº§åˆ«çš„queueåˆ›å»ºä¸€ä¸ªå®šæ—¶ä»»åŠ¡\nå®šæœŸæ£€æŸ¥æ¯ä¸ªå»¶è¿Ÿé˜Ÿåˆ—çš„æ¶ˆæ¯æ˜¯å¦åˆ°æœŸ(ä¸Šä¸€æ­¥ä¼šè®¡ç®—å½“å‰æ—¶é—´ï¼Œå¹¶æ ¹æ®å»¶è¿Ÿç­‰çº§è®¡ç®—å‡ºåˆ°æœŸæ—¶é—´ï¼Œæ³¨æ„è¶…å‡º18ä¼šé»˜è®¤18)\nåˆ°æœŸåï¼Œæ¢å¤åŸå§‹topicå’ŒqueueIdï¼Œé‡æ–°æ„å»ºæ¶ˆæ¯å¹¶å†™å…¥CommitLogï¼Œè¿›å…¥æ­£å¸¸æ¶ˆè´¹æµç¨‹ã€‚\nå…³é”®æºç \norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest\norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage\norg.apache.rocketmq.store.CommitLog#asyncPutMessage\norg.apache.rocketmq.store.schedule.ScheduleMessageService#start\norg.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask\nRocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æ\norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest\né¦–å…ˆæ˜¯æ”¶åˆ°çš„æ¶ˆæ¯å…ˆé€šè¿‡è¿™ä¸ªæ–¹æ³•è¿›è¡Œè½¬å‘å¤„ç†ï¼Œä¸»è¦æ˜¯ç¬¬17è¡Œä»£ç æä¾›å…¥å£ã€‚\n\npublic CompletableFuture<RemotingCommand> asyncProcessRequest(ChannelHandlerContext ctx,\n                                                                  RemotingCommand request) throws RemotingCommandException {\n        final SendMessageContext mqtraceContext;\n        switch (request.getCode()) {\n            case RequestCode.CONSUMER_SEND_MSG_BACK:\n                return this.asyncConsumerSendMsgBack(ctx, request);\n            default:\n                SendMessageRequestHeader requestHeader = parseRequestHeader(request);\n                if (requestHeader == null) {\n                    return CompletableFuture.completedFuture(null);\n                }\n                mqtraceContext = buildMsgContext(ctx, requestHeader);\n                this.executeSendMessageHookBefore(ctx, request, mqtraceContext);\n                if (requestHeader.isBatch()) {\n                    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);\n                } else {\n                    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);\n                }\n        }\n    }\norg.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage\nè¿™é‡Œä¸»è¦çš„æ˜¯å…³æ³¨ç¬¬61è¡Œä»£ç ï¼Œè¿›å…¥åˆ°Stroreï¼Œè¿è¡ŒasyncPutMessageã€‚\n\nprivate CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,\n                                                                SendMessageContext mqtraceContext,\n                                                                SendMessageRequestHeader requestHeader) {\n        final RemotingCommand response = preSend(ctx, request, requestHeader);\n        final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();\n\n        if (response.getCode() != -1) {\n            return CompletableFuture.completedFuture(response);\n        }\n\n        final byte[] body = request.getBody();\n\n        int queueIdInt = requestHeader.getQueueId();\n        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n\n        if (queueIdInt < 0) {\n            queueIdInt = randomQueueId(topicConfig.getWriteQueueNums());\n        }\n\n        MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n        msgInner.setTopic(requestHeader.getTopic());\n        msgInner.setQueueId(queueIdInt);\n\n        if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) {\n            return CompletableFuture.completedFuture(response);\n        }\n\n        msgInner.setBody(body);\n        msgInner.setFlag(requestHeader.getFlag());\n        Map<String, String> origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n        MessageAccessor.setProperties(msgInner, origProps);\n        msgInner.setBornTimestamp(requestHeader.getBornTimestamp());\n        msgInner.setBornHost(ctx.channel().remoteAddress());\n        msgInner.setStoreHost(this.getStoreHost());\n        msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());\n        String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName();\n        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);\n        if (origProps.containsKey(MessageConst.PROPERTY_WAIT_STORE_MSG_OK)) {\n            // There is no need to store \"WAIT=true\", remove it from propertiesString to save 9 bytes for each message.\n            // It works for most case. In some cases msgInner.setPropertiesString invoked later and replace it.\n            String waitStoreMsgOKValue = origProps.remove(MessageConst.PROPERTY_WAIT_STORE_MSG_OK);\n            msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n            // Reput to properties, since msgInner.isWaitStoreMsgOK() will be invoked later\n            origProps.put(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, waitStoreMsgOKValue);\n        } else {\n            msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n        }\n\n        CompletableFuture<PutMessageResult> putMessageResult = null;\n        String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n        if (Boolean.parseBoolean(transFlag)) {\n            if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {\n                response.setCode(ResponseCode.NO_PERMISSION);\n                response.setRemark(\n                        \"the broker[\" + this.brokerController.getBrokerConfig().getBrokerIP1()\n                                + \"] sending transaction message is forbidden\");\n                return CompletableFuture.completedFuture(response);\n            }\n            putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n        } else {\n            putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n        }\n        return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n    }\norg.apache.rocketmq.store.CommitLog#asyncPutMessage\nputMessageçš„è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä¸»è¦çœ‹ç¬¬åå…«è¡Œå¼€å§‹ï¼Œå¦‚æœæ˜¯å»¶è¿Ÿmqï¼Œåˆ™ä¼šå°†æ¶ˆæ¯æ”¾å…¥åˆ°topic=SCHEDULE_TOPIC_XXXX,queueId=delayLevel-1ä¸­\n\npublic CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {\n        // Set the storage time\n        msg.setStoreTimestamp(System.currentTimeMillis());\n        // Set the message body BODY CRC (consider the most appropriate setting\n        // on the client)\n        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));\n        // Back to Results\n        AppendMessageResult result = null;\n\n        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n\n        String topic = msg.getTopic();\n//        int queueId msg.getQueueId();\n        final int tranType = MessageSysFlag.getTransactionValue(msg.getSysFlag());\n        if (tranType == MessageSysFlag.TRANSACTION_NOT_TYPE\n                || tranType == MessageSysFlag.TRANSACTION_COMMIT_TYPE) {\n            // Delay Delivery\n            if (msg.getDelayTimeLevel() > 0) {\n                if (msg.getDelayTimeLevel() > this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {\n                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());\n                }\n\n                topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n                int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n                // Backup real topic, queueId\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n                MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n                msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\n                msg.setTopic(topic);\n                msg.setQueueId(queueId);\n            }\n        }\n\n        InetSocketAddress bornSocketAddress = (InetSocketAddress) msg.getBornHost();\n        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n            msg.setBornHostV6Flag();\n        }\n\n        InetSocketAddress storeSocketAddress = (InetSocketAddress) msg.getStoreHost();\n        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n            msg.setStoreHostAddressV6Flag();\n        }\n\n        PutMessageThreadLocal putMessageThreadLocal = this.putMessageThreadLocal.get();\n        updateMaxMessageSize(putMessageThreadLocal);\n        if (!multiDispatch.isMultiDispatchMsg(msg)) {\n            PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);\n            if (encodeResult != null) {\n                return CompletableFuture.completedFuture(encodeResult);\n            }\n            msg.setEncodedBuff(putMessageThreadLocal.getEncoder().getEncoderBuffer());\n        }\n        PutMessageContext putMessageContext = new PutMessageContext(generateKey(putMessageThreadLocal.getKeyBuilder(), msg));\n\n        long elapsedTimeInLock = 0;\n        MappedFile unlockMappedFile = null;\n\n        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n        try {\n            MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n            long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();\n            this.beginTimeInLock = beginLockTimestamp;\n\n            // Here settings are stored timestamp, in order to ensure an orderly\n            // global\n            msg.setStoreTimestamp(beginLockTimestamp);\n\n            if (null == mappedFile || mappedFile.isFull()) {\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n            }\n            if (null == mappedFile) {\n                log.error(\"create mapped file1 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n            }\n\n            result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n            switch (result.getStatus()) {\n                case PUT_OK:\n                    break;\n                case END_OF_FILE:\n                    unlockMappedFile = mappedFile;\n                    // Create a new file, re-write the message\n                    mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                    if (null == mappedFile) {\n                        // XXX: warn and notify me\n                        log.error(\"create mapped file2 error, topic: \" + msg.getTopic() + \" clientAddr: \" + msg.getBornHostString());\n                        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                    }\n                    result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n                    break;\n                case MESSAGE_SIZE_EXCEEDED:\n                case PROPERTIES_SIZE_EXCEEDED:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n                case UNKNOWN_ERROR:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n                default:\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            }\n\n            elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n        } finally {\n            beginTimeInLock = 0;\n            putMessageLock.unlock();\n        }\n\n        if (elapsedTimeInLock > 500) {\n            log.warn(\"[NOTIFYME]putMessage in lock cost time(ms)={}, bodyLength={} AppendMessageResult={}\", elapsedTimeInLock, msg.getBody().length, result);\n        }\n\n        if (null != unlockMappedFile && this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) {\n            this.defaultMessageStore.unlockMappedFile(unlockMappedFile);\n        }\n\n        PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);\n\n        // Statistics\n        storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).add(1);\n        storeStatsService.getSinglePutMessageTopicSizeTotal(topic).add(result.getWroteBytes());\n\n        CompletableFuture<PutMessageStatus> flushResultFuture = submitFlushRequest(result, msg);\n        CompletableFuture<PutMessageStatus> replicaResultFuture = submitReplicaRequest(result, msg);\n        return flushResultFuture.thenCombine(replicaResultFuture, (flushStatus, replicaStatus) -> {\n            if (flushStatus != PutMessageStatus.PUT_OK) {\n                putMessageResult.setPutMessageStatus(flushStatus);\n            }\n            if (replicaStatus != PutMessageStatus.PUT_OK) {\n                putMessageResult.setPutMessageStatus(replicaStatus);\n            }\n            return putMessageResult;\n        });\n    }\norg.apache.rocketmq.store.schedule.ScheduleMessageService#start\nè¿™é‡Œä¸»è¦æ˜¯è§£é‡Šscheduleå¯¹æ¯ä¸€ä¸ªdelayLeveléƒ½å¯åŠ¨äº†ä¸€ä¸ªå®šæ—¶ä»»åŠ¡çº¿ç¨‹ï¼Œæ‰§è¡Œé¢‘ç‡æ ¹æ®ä¸åŒdelayLevelå¯¹åº”çš„deladeliveryTimeå†³å®šã€‚\n\npublic void start() {\n        if (started.compareAndSet(false, true)) {\n            this.load();\n            this.deliverExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageTimerThread_\"));\n            if (this.enableAsyncDeliver) {\n                this.handleExecutorService = new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(\"ScheduleMessageExecutorHandleThread_\"));\n            }\n            for (Map.Entry<Integer, Long> entry : this.delayLevelTable.entrySet()) {\n                Integer level = entry.getKey();\n                Long timeDelay = entry.getValue();\n                Long offset = this.offsetTable.get(level);\n                if (null == offset) {\n                    offset = 0L;\n                }\n\n                if (timeDelay != null) {\n                    if (this.enableAsyncDeliver) {\n                        this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                    }\n                    this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                }\n            }\n\n            this.deliverExecutorService.scheduleAtFixedRate(new Runnable() {\n\n                @Override\n                public void run() {\n                    try {\n                        if (started.get()) {\n                            ScheduleMessageService.this.persist();\n                        }\n                    } catch (Throwable e) {\n                        log.error(\"scheduleAtFixedRate flush exception\", e);\n                    }\n                }\n            }, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n        }\n    }\norg.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask\ntaskä¸»è¦çš„ä»»åŠ¡å°±æ˜¯101è¡Œï¼Œè°ƒç”¨org.apache.rocketmq.store.schedule.ScheduleMessageService#messageTimeupï¼Œå°†å¯¹è±¡è½¬æ¢æˆMessageExtBrokerInnerå¯¹è±¡ï¼ˆå¹¶åœ¨æ­¤æ—¶å°†topicå’ŒqueueIdé‡ç½®æˆåŸæ¥çš„ï¼‰ï¼Œç„¶åè°ƒç”¨org.apache.rocketmq.store.DefaultMessageStore#putMessageï¼Œå°†æ¶ˆæ¯æ”¾å…¥åˆ°commitLogä¸­ã€‚\n\nclass DeliverDelayedMessageTimerTask implements Runnable {\n        private final int delayLevel;\n        private final long offset;\n\n        public DeliverDelayedMessageTimerTask(int delayLevel, long offset) {\n            this.delayLevel = delayLevel;\n            this.offset = offset;\n        }\n\n        @Override\n        public void run() {\n            try {\n                if (isStarted()) {\n                    this.executeOnTimeup();\n                }\n            } catch (Exception e) {\n                // XXX: warn and notify me\n                log.error(\"ScheduleMessageService, executeOnTimeup exception\", e);\n                this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);\n            }\n        }\n\n        /**\n         * @return\n         */\n        private long correctDeliverTimestamp(final long now, final long deliverTimestamp) {\n\n            long result = deliverTimestamp;\n\n            long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);\n            if (deliverTimestamp > maxTimestamp) {\n                result = now;\n            }\n\n            return result;\n        }\n\n        public void executeOnTimeup() {\n            ConsumeQueue cq =\n                ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC,\n                    delayLevel2QueueId(delayLevel));\n\n            if (cq == null) {\n                this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE);\n                return;\n            }\n\n            SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);\n            if (bufferCQ == null) {\n                long resetOffset;\n                if ((resetOffset = cq.getMinOffsetInQueue()) > this.offset) {\n                    log.error(\"schedule CQ offset invalid. offset={}, cqMinOffset={}, queueId={}\",\n                        this.offset, resetOffset, cq.getQueueId());\n                } else if ((resetOffset = cq.getMaxOffsetInQueue()) < this.offset) {\n                    log.error(\"schedule CQ offset invalid. offset={}, cqMaxOffset={}, queueId={}\",\n                        this.offset, resetOffset, cq.getQueueId());\n                } else {\n                    resetOffset = this.offset;\n                }\n\n                this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE);\n                return;\n            }\n\n            long nextOffset = this.offset;\n            try {\n                int i = 0;\n                ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();\n                for (; i < bufferCQ.getSize() && isStarted(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) {\n                    long offsetPy = bufferCQ.getByteBuffer().getLong();\n                    int sizePy = bufferCQ.getByteBuffer().getInt();\n                    long tagsCode = bufferCQ.getByteBuffer().getLong();\n\n                    if (cq.isExtAddr(tagsCode)) {\n                        if (cq.getExt(tagsCode, cqExtUnit)) {\n                            tagsCode = cqExtUnit.getTagsCode();\n                        } else {\n                            //can't find ext content.So re compute tags code.\n                            log.error(\"[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}\",\n                                tagsCode, offsetPy, sizePy);\n                            long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);\n                            tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);\n                        }\n                    }\n\n                    long now = System.currentTimeMillis();\n                    long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);\n                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n                    long countdown = deliverTimestamp - now;\n                    if (countdown > 0) {\n                        this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                        return;\n                    }\n\n                    MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);\n                    if (msgExt == null) {\n                        continue;\n                    }\n\n                    MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt);\n                    if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) {\n                        log.error(\"[BUG] the real topic of schedule msg is {}, discard the msg. msg={}\",\n                            msgInner.getTopic(), msgInner);\n                        continue;\n                    }\n\n                    boolean deliverSuc;\n                    if (ScheduleMessageService.this.enableAsyncDeliver) {\n                        deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                    } else {\n                        deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                    }\n\n                    if (!deliverSuc) {\n                        this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                        return;\n                    }\n                }\n\n                nextOffset = this.offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n            } catch (Exception e) {\n                log.error(\"ScheduleMessageService, messageTimeup execute error, offset = {}\", nextOffset, e);\n            } finally {\n                bufferCQ.release();\n            }\n\n            this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n        }\n\n        public void scheduleNextTimerTask(long offset, long delay) {\n            ScheduleMessageService.this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(\n                this.delayLevel, offset), delay, TimeUnit.MILLISECONDS);\n        }\n\n        private boolean syncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n            int sizePy) {\n            PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, false);\n            PutMessageResult result = resultProcess.get();\n            boolean sendStatus = result != null && result.getPutMessageStatus() == PutMessageStatus.PUT_OK;\n            if (sendStatus) {\n                ScheduleMessageService.this.updateOffset(this.delayLevel, resultProcess.getNextOffset());\n            }\n            return sendStatus;\n        }\n\n        private boolean asyncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n            int sizePy) {\n            Queue<PutResultProcess> processesQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel);\n\n            //Flow Control\n            int currentPendingNum = processesQueue.size();\n            int maxPendingLimit = ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig()\n                .getScheduleAsyncDeliverMaxPendingLimit();\n            if (currentPendingNum > maxPendingLimit) {\n                log.warn(\"Asynchronous deliver triggers flow control, \" +\n                    \"currentPendingNum={}, maxPendingLimit={}\", currentPendingNum, maxPendingLimit);\n                return false;\n            }\n\n            //Blocked\n            PutResultProcess firstProcess = processesQueue.peek();\n            if (firstProcess != null && firstProcess.need2Blocked()) {\n                log.warn(\"Asynchronous deliver block. info={}\", firstProcess.toString());\n                return false;\n            }\n\n            PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, true);\n            processesQueue.add(resultProcess);\n            return true;\n        }\n\n        private PutResultProcess deliverMessage(MessageExtBrokerInner msgInner, String msgId, long offset,\n            long offsetPy, int sizePy, boolean autoResend) {\n            CompletableFuture<PutMessageResult> future =\n                ScheduleMessageService.this.writeMessageStore.asyncPutMessage(msgInner);\n            return new PutResultProcess()\n                .setTopic(msgInner.getTopic())\n                .setDelayLevel(this.delayLevel)\n                .setOffset(offset)\n                .setPhysicOffset(offsetPy)\n                .setPhysicSize(sizePy)\n                .setMsgId(msgId)\n                .setAutoResend(autoResend)\n                .setFuture(future)\n                .thenProcess();\n        }\n    }\nRocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£\nå­—æ®µmessage.deliveryTimestamp\nå¯ä»¥é¢„å®šè§¦å‘çš„æ—¶é—´æˆ³ï¼Œè€Œä¸æ˜¯å»¶æ—¶æ—¶é•¿\næ”¯æŒä»¥æ ¼å¼ä¸ºæ¯«ç§’çº§unixæ—¶é—´æˆ³ï¼ˆé»˜è®¤1000æ¯«ç§’çš„ç²¾åº¦ä¹Ÿå°±æ˜¯1ç§’ï¼‰\næ”¯æŒæœ€é•¿24å°æ—¶ï¼Œä¸æ”¯æŒè‡ªå®šä¹‰ä¿®æ”¹ï¼Œè¶…è¿‡24å°æ—¶å»¶æ—¶ä¸ç”Ÿæ•ˆï¼ŒæœåŠ¡ç«¯ä¼šç«‹å³æŠ•é€’\nå®šæ—¶ä»»åŠ¡ä»…æ”¯æŒå‘é€åˆ°MessageTypeä¸ºDelayçš„Topicä¸­\nRocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æ\nRocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æ\nå†™åœ¨æœ€å\n     åœ¨2025å¹´09æœˆ18æ—¥ï¼Œå¿ƒè¡€æ¥æ½®åœ¨githubä¸Šæœç´¢rocketMQçš„å»¶è¿Ÿmqï¼Œå‘ç°äº†2018å¹´çš„ä¸€äº›ç‚¹ç‚¹æ»´æ»´ã€‚\n     æœ‰è‡ªå·±ä¸ºäº†å­¦ä¹ aiå¹¶ä½œä¸ºæ¯•è®¾çš„ä»“åº“ï¼Œæœ‰åŒå­¦å¸¦æˆ‘ç©çš„hexo + githubå®ç°çš„ç®€å•ä¸ªäººåšå®¢ã€‚\n     åœ¨çœ‹å®Œæ–‡æ¡£å’Œä»£ç ä¹‹åç™¾æ„Ÿäº¤é›†ï¼Œç»ˆäºæ‰“ç®—é‡æ–°å¼€å§‹å†™åšå®¢ã€‚ä¸çŸ¥é“è¿™æ¬¡è¿˜èƒ½åšæŒå¤šä¹…ï¼Œä½†æ˜¯æ—¢ç„¶è‡ªå·±èƒ½ä¸€å£æ°”å‡è‚¥æ‰äº†43æ–¤ï¼ˆæˆªè‡³ç›®å‰ï¼‰ï¼Œé‚£ä¹ˆè¿˜æœ‰ä»€ä¹ˆä¸èƒ½çš„å‘¢ï¼Ÿ\n     åŠ æ²¹å§è‡ªå·±ï¼Œåœ¨æ²¡æœ‰ç›®æ ‡çš„æ—¶å€™å¥½å¥½ç§¯ç´¯ï¼Œåšç§¯è–„å‘ã€‚","slug":"RocketMQå»¶æ—¶MQçš„åŸç†é˜…è¯»","published":1,"updated":"2025-09-24T05:08:39.469Z","_id":"cmfqf6qtj0000kgu7a8n8a6iz","comments":1,"layout":"post","photos":[],"content":"<p>status: draft<br>createDate: 2025-09-19 11:44:41<br>endDate:</p>\n<h2 id=\"ç›®å½•\"><a href=\"#ç›®å½•\" class=\"headerlink\" title=\"ç›®å½•\"></a>ç›®å½•</h2><h3 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"></a><a href=\"#rocketmq-4.x-now\">RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸</a></h3><h3 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\"></a>RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸</h3><h3 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\"></a>RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸</h3><h3 id=\"RocketMQ-5-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"><a href=\"#RocketMQ-5-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"></a>RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸</h3><h3 id=\"RocketMQ-5-Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\"><a href=\"#RocketMQ-5-Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\" class=\"headerlink\" title=\"RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\"></a>RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ</h3><h3 id=\"RocketMQ-5-Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\"><a href=\"#RocketMQ-5-Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\" class=\"headerlink\" title=\"RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\"></a>RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æâ¬œ</h3><h3 id=\"å†™åœ¨æœ€å\"><a href=\"#å†™åœ¨æœ€å\" class=\"headerlink\" title=\"å†™åœ¨æœ€å\"></a>å†™åœ¨æœ€å</h3><h2 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶-å®˜æ–¹æ–‡æ¡£\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶-å®˜æ–¹æ–‡æ¡£\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£\"></a>RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£<a id=\"rocketmq-4.x-now\"></a></h2><p>å­—æ®µmessage.delayTimeLevel<br>æšä¸¾ä¸ºæ•°å­—1-18ï¼Œåªæ”¯æŒ18ä¸ªå›ºå®šå»¶æ—¶ç­‰çº§ï¼ˆ1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2hï¼‰<br>RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æ<br>åº•å±‚å®ç°ä¸»è¦æ˜¯åŸºäºBrokeç«¯ï¼Œä¸»è¦æ¶‰åŠä»¥ä¸‹ç»„ä»¶ï¼š</p>\n<ol>\n<li>CommitLog å†™å…¥å¤„<br>å½“æ¶ˆæ¯å¸¦æœ‰delayTimeLevel &gt; 0æ—¶ï¼Œåœ¨CommitLog#asyncPutMessageæ–¹æ³•ä¸­ä¼šè¿›è¡Œç‰¹æ®Šå¤„ç†(è€ç‰ˆæœ¬æ˜¯CommitLog#putMessage)</li>\n</ol>\n<ul>\n<li>å°†åŸå§‹çš„topicå’ŒqueueIdä¿å­˜åˆ°æ¶ˆæ¯å±æ€§ä¸­(REAL_TOPICã€REAL_QUEUE_ID)</li>\n<li>ä¿®æ”¹æ¶ˆæ¯çš„topicä¸ºç³»ç»Ÿé¢„è®¾çš„å»¶è¿Ÿtopic(SCHEDULE_TOPIC_XXXX)</li>\n<li>æ ¹æ®å»¶è¿Ÿçº§åˆ«è®¡ç®—å‡ºå¯¹åº”çš„queueId ScheduleMessageService#delayLevel2QueueIdå¹¶æŠ•æ”¾åˆ°å¯¹åº”çš„queueä¸­</li>\n</ul>\n<ol start=\"2\">\n<li>å®šæ—¶è°ƒåº¦æœåŠ¡ScheduleMessageService<br>è¯¥æœåŠ¡è´Ÿè´£æ‰«æå»¶è¿Ÿé˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ï¼Œå¹¶åœ¨åˆ°æœŸåå°†å…¶é‡æ–°æŠ•é€’åˆ°åŸå§‹çš„topic<br>å¯åŠ¨æ—¶ä¸ºæ¯ä¸€ä¸ªå»¶è¿Ÿçº§åˆ«çš„queueåˆ›å»ºä¸€ä¸ªå®šæ—¶ä»»åŠ¡<br>å®šæœŸæ£€æŸ¥æ¯ä¸ªå»¶è¿Ÿé˜Ÿåˆ—çš„æ¶ˆæ¯æ˜¯å¦åˆ°æœŸ(ä¸Šä¸€æ­¥ä¼šè®¡ç®—å½“å‰æ—¶é—´ï¼Œå¹¶æ ¹æ®å»¶è¿Ÿç­‰çº§è®¡ç®—å‡ºåˆ°æœŸæ—¶é—´ï¼Œæ³¨æ„è¶…å‡º18ä¼šé»˜è®¤18)<br>åˆ°æœŸåï¼Œæ¢å¤åŸå§‹topicå’ŒqueueIdï¼Œé‡æ–°æ„å»ºæ¶ˆæ¯å¹¶å†™å…¥CommitLogï¼Œè¿›å…¥æ­£å¸¸æ¶ˆè´¹æµç¨‹ã€‚<br>å…³é”®æºç <br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest<br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage<br>org.apache.rocketmq.store.CommitLog#asyncPutMessage<br>org.apache.rocketmq.store.schedule.ScheduleMessageService#start<br>org.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask<br>RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æ<br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest<br>é¦–å…ˆæ˜¯æ”¶åˆ°çš„æ¶ˆæ¯å…ˆé€šè¿‡è¿™ä¸ªæ–¹æ³•è¿›è¡Œè½¬å‘å¤„ç†ï¼Œä¸»è¦æ˜¯ç¬¬17è¡Œä»£ç æä¾›å…¥å£ã€‚</li>\n</ol>\n<p>public CompletableFuture<RemotingCommand> asyncProcessRequest(ChannelHandlerContext ctx,<br>                                                                  RemotingCommand request) throws RemotingCommandException {<br>        final SendMessageContext mqtraceContext;<br>        switch (request.getCode()) {<br>            case RequestCode.CONSUMER_SEND_MSG_BACK:<br>                return this.asyncConsumerSendMsgBack(ctx, request);<br>            default:<br>                SendMessageRequestHeader requestHeader &#x3D; parseRequestHeader(request);<br>                if (requestHeader &#x3D;&#x3D; null) {<br>                    return CompletableFuture.completedFuture(null);<br>                }<br>                mqtraceContext &#x3D; buildMsgContext(ctx, requestHeader);<br>                this.executeSendMessageHookBefore(ctx, request, mqtraceContext);<br>                if (requestHeader.isBatch()) {<br>                    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);<br>                } else {<br>                    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);<br>                }<br>        }<br>    }<br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage<br>è¿™é‡Œä¸»è¦çš„æ˜¯å…³æ³¨ç¬¬61è¡Œä»£ç ï¼Œè¿›å…¥åˆ°Stroreï¼Œè¿è¡ŒasyncPutMessageã€‚</p>\n<p>private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,<br>                                                                SendMessageContext mqtraceContext,<br>                                                                SendMessageRequestHeader requestHeader) {<br>        final RemotingCommand response &#x3D; preSend(ctx, request, requestHeader);<br>        final SendMessageResponseHeader responseHeader &#x3D; (SendMessageResponseHeader)response.readCustomHeader();</p>\n<pre><code>    if (response.getCode() != -1) &#123;\n        return CompletableFuture.completedFuture(response);\n    &#125;\n\n    final byte[] body = request.getBody();\n\n    int queueIdInt = requestHeader.getQueueId();\n    TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n\n    if (queueIdInt &lt; 0) &#123;\n        queueIdInt = randomQueueId(topicConfig.getWriteQueueNums());\n    &#125;\n\n    MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n    msgInner.setTopic(requestHeader.getTopic());\n    msgInner.setQueueId(queueIdInt);\n\n    if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;\n        return CompletableFuture.completedFuture(response);\n    &#125;\n\n    msgInner.setBody(body);\n    msgInner.setFlag(requestHeader.getFlag());\n    Map&lt;String, String&gt; origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n    MessageAccessor.setProperties(msgInner, origProps);\n    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());\n    msgInner.setBornHost(ctx.channel().remoteAddress());\n    msgInner.setStoreHost(this.getStoreHost());\n    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());\n    String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName();\n    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);\n    if (origProps.containsKey(MessageConst.PROPERTY_WAIT_STORE_MSG_OK)) &#123;\n        // There is no need to store &quot;WAIT=true&quot;, remove it from propertiesString to save 9 bytes for each message.\n        // It works for most case. In some cases msgInner.setPropertiesString invoked later and replace it.\n        String waitStoreMsgOKValue = origProps.remove(MessageConst.PROPERTY_WAIT_STORE_MSG_OK);\n        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n        // Reput to properties, since msgInner.isWaitStoreMsgOK() will be invoked later\n        origProps.put(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, waitStoreMsgOKValue);\n    &#125; else &#123;\n        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n    &#125;\n\n    CompletableFuture&lt;PutMessageResult&gt; putMessageResult = null;\n    String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n    if (Boolean.parseBoolean(transFlag)) &#123;\n        if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\n                    &quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1()\n                            + &quot;] sending transaction message is forbidden&quot;);\n            return CompletableFuture.completedFuture(response);\n        &#125;\n        putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n    &#125; else &#123;\n        putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n    &#125;\n    return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n&#125;\n</code></pre>\n<p>org.apache.rocketmq.store.CommitLog#asyncPutMessage<br>putMessageçš„è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä¸»è¦çœ‹ç¬¬åå…«è¡Œå¼€å§‹ï¼Œå¦‚æœæ˜¯å»¶è¿Ÿmqï¼Œåˆ™ä¼šå°†æ¶ˆæ¯æ”¾å…¥åˆ°topic&#x3D;SCHEDULE_TOPIC_XXXX,queueId&#x3D;delayLevel-1ä¸­</p>\n<p>public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {<br>        &#x2F;&#x2F; Set the storage time<br>        msg.setStoreTimestamp(System.currentTimeMillis());<br>        &#x2F;&#x2F; Set the message body BODY CRC (consider the most appropriate setting<br>        &#x2F;&#x2F; on the client)<br>        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));<br>        &#x2F;&#x2F; Back to Results<br>        AppendMessageResult result &#x3D; null;</p>\n<pre><code>    StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n\n    String topic = msg.getTopic();\n</code></pre>\n<p>&#x2F;&#x2F;        int queueId msg.getQueueId();<br>        final int tranType &#x3D; MessageSysFlag.getTransactionValue(msg.getSysFlag());<br>        if (tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_NOT_TYPE<br>                || tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_COMMIT_TYPE) {<br>            &#x2F;&#x2F; Delay Delivery<br>            if (msg.getDelayTimeLevel() &gt; 0) {<br>                if (msg.getDelayTimeLevel() &gt; this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {<br>                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());<br>                }</p>\n<pre><code>            topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n            int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n            // Backup real topic, queueId\n            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\n            msg.setTopic(topic);\n            msg.setQueueId(queueId);\n        &#125;\n    &#125;\n\n    InetSocketAddress bornSocketAddress = (InetSocketAddress) msg.getBornHost();\n    if (bornSocketAddress.getAddress() instanceof Inet6Address) &#123;\n        msg.setBornHostV6Flag();\n    &#125;\n\n    InetSocketAddress storeSocketAddress = (InetSocketAddress) msg.getStoreHost();\n    if (storeSocketAddress.getAddress() instanceof Inet6Address) &#123;\n        msg.setStoreHostAddressV6Flag();\n    &#125;\n\n    PutMessageThreadLocal putMessageThreadLocal = this.putMessageThreadLocal.get();\n    updateMaxMessageSize(putMessageThreadLocal);\n    if (!multiDispatch.isMultiDispatchMsg(msg)) &#123;\n        PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);\n        if (encodeResult != null) &#123;\n            return CompletableFuture.completedFuture(encodeResult);\n        &#125;\n        msg.setEncodedBuff(putMessageThreadLocal.getEncoder().getEncoderBuffer());\n    &#125;\n    PutMessageContext putMessageContext = new PutMessageContext(generateKey(putMessageThreadLocal.getKeyBuilder(), msg));\n\n    long elapsedTimeInLock = 0;\n    MappedFile unlockMappedFile = null;\n\n    putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n    try &#123;\n        MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n        long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();\n        this.beginTimeInLock = beginLockTimestamp;\n\n        // Here settings are stored timestamp, in order to ensure an orderly\n        // global\n        msg.setStoreTimestamp(beginLockTimestamp);\n\n        if (null == mappedFile || mappedFile.isFull()) &#123;\n            mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n        &#125;\n        if (null == mappedFile) &#123;\n            log.error(&quot;create mapped file1 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());\n            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n        &#125;\n\n        result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n        switch (result.getStatus()) &#123;\n            case PUT_OK:\n                break;\n            case END_OF_FILE:\n                unlockMappedFile = mappedFile;\n                // Create a new file, re-write the message\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                if (null == mappedFile) &#123;\n                    // XXX: warn and notify me\n                    log.error(&quot;create mapped file2 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                &#125;\n                result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n                break;\n            case MESSAGE_SIZE_EXCEEDED:\n            case PROPERTIES_SIZE_EXCEEDED:\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n            case UNKNOWN_ERROR:\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            default:\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n        &#125;\n\n        elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n    &#125; finally &#123;\n        beginTimeInLock = 0;\n        putMessageLock.unlock();\n    &#125;\n\n    if (elapsedTimeInLock &gt; 500) &#123;\n        log.warn(&quot;[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;&quot;, elapsedTimeInLock, msg.getBody().length, result);\n    &#125;\n\n    if (null != unlockMappedFile &amp;&amp; this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;\n        this.defaultMessageStore.unlockMappedFile(unlockMappedFile);\n    &#125;\n\n    PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);\n\n    // Statistics\n    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).add(1);\n    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).add(result.getWroteBytes());\n\n    CompletableFuture&lt;PutMessageStatus&gt; flushResultFuture = submitFlushRequest(result, msg);\n    CompletableFuture&lt;PutMessageStatus&gt; replicaResultFuture = submitReplicaRequest(result, msg);\n    return flushResultFuture.thenCombine(replicaResultFuture, (flushStatus, replicaStatus) -&gt; &#123;\n        if (flushStatus != PutMessageStatus.PUT_OK) &#123;\n            putMessageResult.setPutMessageStatus(flushStatus);\n        &#125;\n        if (replicaStatus != PutMessageStatus.PUT_OK) &#123;\n            putMessageResult.setPutMessageStatus(replicaStatus);\n        &#125;\n        return putMessageResult;\n    &#125;);\n&#125;\n</code></pre>\n<p>org.apache.rocketmq.store.schedule.ScheduleMessageService#start<br>è¿™é‡Œä¸»è¦æ˜¯è§£é‡Šscheduleå¯¹æ¯ä¸€ä¸ªdelayLeveléƒ½å¯åŠ¨äº†ä¸€ä¸ªå®šæ—¶ä»»åŠ¡çº¿ç¨‹ï¼Œæ‰§è¡Œé¢‘ç‡æ ¹æ®ä¸åŒdelayLevelå¯¹åº”çš„deladeliveryTimeå†³å®šã€‚</p>\n<p>public void start() {<br>        if (started.compareAndSet(false, true)) {<br>            this.load();<br>            this.deliverExecutorService &#x3D; new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(â€œScheduleMessageTimerThread_â€));<br>            if (this.enableAsyncDeliver) {<br>                this.handleExecutorService &#x3D; new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(â€œScheduleMessageExecutorHandleThread_â€));<br>            }<br>            for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) {<br>                Integer level &#x3D; entry.getKey();<br>                Long timeDelay &#x3D; entry.getValue();<br>                Long offset &#x3D; this.offsetTable.get(level);<br>                if (null &#x3D;&#x3D; offset) {<br>                    offset &#x3D; 0L;<br>                }</p>\n<pre><code>            if (timeDelay != null) &#123;\n                if (this.enableAsyncDeliver) &#123;\n                    this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                &#125;\n                this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n            &#125;\n        &#125;\n\n        this.deliverExecutorService.scheduleAtFixedRate(new Runnable() &#123;\n\n            @Override\n            public void run() &#123;\n                try &#123;\n                    if (started.get()) &#123;\n                        ScheduleMessageService.this.persist();\n                    &#125;\n                &#125; catch (Throwable e) &#123;\n                    log.error(&quot;scheduleAtFixedRate flush exception&quot;, e);\n                &#125;\n            &#125;\n        &#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n    &#125;\n&#125;\n</code></pre>\n<p>org.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask<br>taskä¸»è¦çš„ä»»åŠ¡å°±æ˜¯101è¡Œï¼Œè°ƒç”¨org.apache.rocketmq.store.schedule.ScheduleMessageService#messageTimeupï¼Œå°†å¯¹è±¡è½¬æ¢æˆMessageExtBrokerInnerå¯¹è±¡ï¼ˆå¹¶åœ¨æ­¤æ—¶å°†topicå’ŒqueueIdé‡ç½®æˆåŸæ¥çš„ï¼‰ï¼Œç„¶åè°ƒç”¨org.apache.rocketmq.store.DefaultMessageStore#putMessageï¼Œå°†æ¶ˆæ¯æ”¾å…¥åˆ°commitLogä¸­ã€‚</p>\n<p>class DeliverDelayedMessageTimerTask implements Runnable {<br>        private final int delayLevel;<br>        private final long offset;</p>\n<pre><code>    public DeliverDelayedMessageTimerTask(int delayLevel, long offset) &#123;\n        this.delayLevel = delayLevel;\n        this.offset = offset;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        try &#123;\n            if (isStarted()) &#123;\n                this.executeOnTimeup();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            // XXX: warn and notify me\n            log.error(&quot;ScheduleMessageService, executeOnTimeup exception&quot;, e);\n            this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);\n        &#125;\n    &#125;\n\n    /**\n     * @return\n     */\n    private long correctDeliverTimestamp(final long now, final long deliverTimestamp) &#123;\n\n        long result = deliverTimestamp;\n\n        long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);\n        if (deliverTimestamp &gt; maxTimestamp) &#123;\n            result = now;\n        &#125;\n\n        return result;\n    &#125;\n\n    public void executeOnTimeup() &#123;\n        ConsumeQueue cq =\n            ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC,\n                delayLevel2QueueId(delayLevel));\n\n        if (cq == null) &#123;\n            this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE);\n            return;\n        &#125;\n\n        SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);\n        if (bufferCQ == null) &#123;\n            long resetOffset;\n            if ((resetOffset = cq.getMinOffsetInQueue()) &gt; this.offset) &#123;\n                log.error(&quot;schedule CQ offset invalid. offset=&#123;&#125;, cqMinOffset=&#123;&#125;, queueId=&#123;&#125;&quot;,\n                    this.offset, resetOffset, cq.getQueueId());\n            &#125; else if ((resetOffset = cq.getMaxOffsetInQueue()) &lt; this.offset) &#123;\n                log.error(&quot;schedule CQ offset invalid. offset=&#123;&#125;, cqMaxOffset=&#123;&#125;, queueId=&#123;&#125;&quot;,\n                    this.offset, resetOffset, cq.getQueueId());\n            &#125; else &#123;\n                resetOffset = this.offset;\n            &#125;\n\n            this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE);\n            return;\n        &#125;\n\n        long nextOffset = this.offset;\n        try &#123;\n            int i = 0;\n            ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();\n            for (; i &lt; bufferCQ.getSize() &amp;&amp; isStarted(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;\n                long offsetPy = bufferCQ.getByteBuffer().getLong();\n                int sizePy = bufferCQ.getByteBuffer().getInt();\n                long tagsCode = bufferCQ.getByteBuffer().getLong();\n\n                if (cq.isExtAddr(tagsCode)) &#123;\n                    if (cq.getExt(tagsCode, cqExtUnit)) &#123;\n                        tagsCode = cqExtUnit.getTagsCode();\n                    &#125; else &#123;\n                        //can&#39;t find ext content.So re compute tags code.\n                        log.error(&quot;[BUG] can&#39;t find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;&quot;,\n                            tagsCode, offsetPy, sizePy);\n                        long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);\n                        tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);\n                    &#125;\n                &#125;\n\n                long now = System.currentTimeMillis();\n                long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);\n                nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n                long countdown = deliverTimestamp - now;\n                if (countdown &gt; 0) &#123;\n                    this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                    return;\n                &#125;\n\n                MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);\n                if (msgExt == null) &#123;\n                    continue;\n                &#125;\n\n                MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt);\n                if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) &#123;\n                    log.error(&quot;[BUG] the real topic of schedule msg is &#123;&#125;, discard the msg. msg=&#123;&#125;&quot;,\n                        msgInner.getTopic(), msgInner);\n                    continue;\n                &#125;\n\n                boolean deliverSuc;\n                if (ScheduleMessageService.this.enableAsyncDeliver) &#123;\n                    deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                &#125; else &#123;\n                    deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                &#125;\n\n                if (!deliverSuc) &#123;\n                    this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                    return;\n                &#125;\n            &#125;\n\n            nextOffset = this.offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;ScheduleMessageService, messageTimeup execute error, offset = &#123;&#125;&quot;, nextOffset, e);\n        &#125; finally &#123;\n            bufferCQ.release();\n        &#125;\n\n        this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n    &#125;\n\n    public void scheduleNextTimerTask(long offset, long delay) &#123;\n        ScheduleMessageService.this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(\n            this.delayLevel, offset), delay, TimeUnit.MILLISECONDS);\n    &#125;\n\n    private boolean syncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n        int sizePy) &#123;\n        PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, false);\n        PutMessageResult result = resultProcess.get();\n        boolean sendStatus = result != null &amp;&amp; result.getPutMessageStatus() == PutMessageStatus.PUT_OK;\n        if (sendStatus) &#123;\n            ScheduleMessageService.this.updateOffset(this.delayLevel, resultProcess.getNextOffset());\n        &#125;\n        return sendStatus;\n    &#125;\n\n    private boolean asyncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n        int sizePy) &#123;\n        Queue&lt;PutResultProcess&gt; processesQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel);\n\n        //Flow Control\n        int currentPendingNum = processesQueue.size();\n        int maxPendingLimit = ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig()\n            .getScheduleAsyncDeliverMaxPendingLimit();\n        if (currentPendingNum &gt; maxPendingLimit) &#123;\n            log.warn(&quot;Asynchronous deliver triggers flow control, &quot; +\n                &quot;currentPendingNum=&#123;&#125;, maxPendingLimit=&#123;&#125;&quot;, currentPendingNum, maxPendingLimit);\n            return false;\n        &#125;\n\n        //Blocked\n        PutResultProcess firstProcess = processesQueue.peek();\n        if (firstProcess != null &amp;&amp; firstProcess.need2Blocked()) &#123;\n            log.warn(&quot;Asynchronous deliver block. info=&#123;&#125;&quot;, firstProcess.toString());\n            return false;\n        &#125;\n\n        PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, true);\n        processesQueue.add(resultProcess);\n        return true;\n    &#125;\n\n    private PutResultProcess deliverMessage(MessageExtBrokerInner msgInner, String msgId, long offset,\n        long offsetPy, int sizePy, boolean autoResend) &#123;\n        CompletableFuture&lt;PutMessageResult&gt; future =\n            ScheduleMessageService.this.writeMessageStore.asyncPutMessage(msgInner);\n        return new PutResultProcess()\n            .setTopic(msgInner.getTopic())\n            .setDelayLevel(this.delayLevel)\n            .setOffset(offset)\n            .setPhysicOffset(offsetPy)\n            .setPhysicSize(sizePy)\n            .setMsgId(msgId)\n            .setAutoResend(autoResend)\n            .setFuture(future)\n            .thenProcess();\n    &#125;\n&#125;\n</code></pre>\n<p>RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£<br>å­—æ®µmessage.deliveryTimestamp<br>å¯ä»¥é¢„å®šè§¦å‘çš„æ—¶é—´æˆ³ï¼Œè€Œä¸æ˜¯å»¶æ—¶æ—¶é•¿<br>æ”¯æŒä»¥æ ¼å¼ä¸ºæ¯«ç§’çº§unixæ—¶é—´æˆ³ï¼ˆé»˜è®¤1000æ¯«ç§’çš„ç²¾åº¦ä¹Ÿå°±æ˜¯1ç§’ï¼‰<br>æ”¯æŒæœ€é•¿24å°æ—¶ï¼Œä¸æ”¯æŒè‡ªå®šä¹‰ä¿®æ”¹ï¼Œè¶…è¿‡24å°æ—¶å»¶æ—¶ä¸ç”Ÿæ•ˆï¼ŒæœåŠ¡ç«¯ä¼šç«‹å³æŠ•é€’<br>å®šæ—¶ä»»åŠ¡ä»…æ”¯æŒå‘é€åˆ°MessageTypeä¸ºDelayçš„Topicä¸­<br>RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æ<br>RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æ<br>å†™åœ¨æœ€å<br>     åœ¨2025å¹´09æœˆ18æ—¥ï¼Œå¿ƒè¡€æ¥æ½®åœ¨githubä¸Šæœç´¢rocketMQçš„å»¶è¿Ÿmqï¼Œå‘ç°äº†2018å¹´çš„ä¸€äº›ç‚¹ç‚¹æ»´æ»´ã€‚<br>     æœ‰è‡ªå·±ä¸ºäº†å­¦ä¹ aiå¹¶ä½œä¸ºæ¯•è®¾çš„ä»“åº“ï¼Œæœ‰åŒå­¦å¸¦æˆ‘ç©çš„hexo + githubå®ç°çš„ç®€å•ä¸ªäººåšå®¢ã€‚<br>     åœ¨çœ‹å®Œæ–‡æ¡£å’Œä»£ç ä¹‹åç™¾æ„Ÿäº¤é›†ï¼Œç»ˆäºæ‰“ç®—é‡æ–°å¼€å§‹å†™åšå®¢ã€‚ä¸çŸ¥é“è¿™æ¬¡è¿˜èƒ½åšæŒå¤šä¹…ï¼Œä½†æ˜¯æ—¢ç„¶è‡ªå·±èƒ½ä¸€å£æ°”å‡è‚¥æ‰äº†43æ–¤ï¼ˆæˆªè‡³ç›®å‰ï¼‰ï¼Œé‚£ä¹ˆè¿˜æœ‰ä»€ä¹ˆä¸èƒ½çš„å‘¢ï¼Ÿ<br>     åŠ æ²¹å§è‡ªå·±ï¼Œåœ¨æ²¡æœ‰ç›®æ ‡çš„æ—¶å€™å¥½å¥½ç§¯ç´¯ï¼Œåšç§¯è–„å‘ã€‚</p>\n","excerpt":"","more":"<p>status: draft<br>createDate: 2025-09-19 11:44:41<br>endDate:</p>\n<h2 id=\"ç›®å½•\"><a href=\"#ç›®å½•\" class=\"headerlink\" title=\"ç›®å½•\"></a>ç›®å½•</h2><h3 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"></a><a href=\"#rocketmq-4.x-now\">RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸</a></h3><h3 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸\"></a>RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æâ˜‘ï¸</h3><h3 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸\"></a>RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æâ˜‘ï¸</h3><h3 id=\"RocketMQ-5-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"><a href=\"#RocketMQ-5-Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\" class=\"headerlink\" title=\"RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸\"></a>RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶â˜‘ï¸</h3><h3 id=\"RocketMQ-5-Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\"><a href=\"#RocketMQ-5-Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\" class=\"headerlink\" title=\"RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ\"></a>RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æâ¬œ</h3><h3 id=\"RocketMQ-5-Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\"><a href=\"#RocketMQ-5-Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\" class=\"headerlink\" title=\"RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æâ¬œ\"></a>RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æâ¬œ</h3><h3 id=\"å†™åœ¨æœ€å\"><a href=\"#å†™åœ¨æœ€å\" class=\"headerlink\" title=\"å†™åœ¨æœ€å\"></a>å†™åœ¨æœ€å</h3><h2 id=\"RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶-å®˜æ–¹æ–‡æ¡£\"><a href=\"#RocketMQ-4-Xçš„å»¶æ—¶MQç°çŠ¶-å®˜æ–¹æ–‡æ¡£\" class=\"headerlink\" title=\"RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£\"></a>RocketMQ 4.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£<a id=\"rocketmq-4.x-now\"></a></h2><p>å­—æ®µmessage.delayTimeLevel<br>æšä¸¾ä¸ºæ•°å­—1-18ï¼Œåªæ”¯æŒ18ä¸ªå›ºå®šå»¶æ—¶ç­‰çº§ï¼ˆ1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2hï¼‰<br>RocketMQ 4.Xçš„å»¶æ—¶MQåŸç†è§£æ<br>åº•å±‚å®ç°ä¸»è¦æ˜¯åŸºäºBrokeç«¯ï¼Œä¸»è¦æ¶‰åŠä»¥ä¸‹ç»„ä»¶ï¼š</p>\n<ol>\n<li>CommitLog å†™å…¥å¤„<br>å½“æ¶ˆæ¯å¸¦æœ‰delayTimeLevel &gt; 0æ—¶ï¼Œåœ¨CommitLog#asyncPutMessageæ–¹æ³•ä¸­ä¼šè¿›è¡Œç‰¹æ®Šå¤„ç†(è€ç‰ˆæœ¬æ˜¯CommitLog#putMessage)</li>\n</ol>\n<ul>\n<li>å°†åŸå§‹çš„topicå’ŒqueueIdä¿å­˜åˆ°æ¶ˆæ¯å±æ€§ä¸­(REAL_TOPICã€REAL_QUEUE_ID)</li>\n<li>ä¿®æ”¹æ¶ˆæ¯çš„topicä¸ºç³»ç»Ÿé¢„è®¾çš„å»¶è¿Ÿtopic(SCHEDULE_TOPIC_XXXX)</li>\n<li>æ ¹æ®å»¶è¿Ÿçº§åˆ«è®¡ç®—å‡ºå¯¹åº”çš„queueId ScheduleMessageService#delayLevel2QueueIdå¹¶æŠ•æ”¾åˆ°å¯¹åº”çš„queueä¸­</li>\n</ul>\n<ol start=\"2\">\n<li>å®šæ—¶è°ƒåº¦æœåŠ¡ScheduleMessageService<br>è¯¥æœåŠ¡è´Ÿè´£æ‰«æå»¶è¿Ÿé˜Ÿåˆ—ä¸­çš„æ¶ˆæ¯ï¼Œå¹¶åœ¨åˆ°æœŸåå°†å…¶é‡æ–°æŠ•é€’åˆ°åŸå§‹çš„topic<br>å¯åŠ¨æ—¶ä¸ºæ¯ä¸€ä¸ªå»¶è¿Ÿçº§åˆ«çš„queueåˆ›å»ºä¸€ä¸ªå®šæ—¶ä»»åŠ¡<br>å®šæœŸæ£€æŸ¥æ¯ä¸ªå»¶è¿Ÿé˜Ÿåˆ—çš„æ¶ˆæ¯æ˜¯å¦åˆ°æœŸ(ä¸Šä¸€æ­¥ä¼šè®¡ç®—å½“å‰æ—¶é—´ï¼Œå¹¶æ ¹æ®å»¶è¿Ÿç­‰çº§è®¡ç®—å‡ºåˆ°æœŸæ—¶é—´ï¼Œæ³¨æ„è¶…å‡º18ä¼šé»˜è®¤18)<br>åˆ°æœŸåï¼Œæ¢å¤åŸå§‹topicå’ŒqueueIdï¼Œé‡æ–°æ„å»ºæ¶ˆæ¯å¹¶å†™å…¥CommitLogï¼Œè¿›å…¥æ­£å¸¸æ¶ˆè´¹æµç¨‹ã€‚<br>å…³é”®æºç <br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest<br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage<br>org.apache.rocketmq.store.CommitLog#asyncPutMessage<br>org.apache.rocketmq.store.schedule.ScheduleMessageService#start<br>org.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask<br>RocketMQ 4.Xçš„å»¶æ—¶MQæºç è§£æ<br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncProcessRequest<br>é¦–å…ˆæ˜¯æ”¶åˆ°çš„æ¶ˆæ¯å…ˆé€šè¿‡è¿™ä¸ªæ–¹æ³•è¿›è¡Œè½¬å‘å¤„ç†ï¼Œä¸»è¦æ˜¯ç¬¬17è¡Œä»£ç æä¾›å…¥å£ã€‚</li>\n</ol>\n<p>public CompletableFuture<RemotingCommand> asyncProcessRequest(ChannelHandlerContext ctx,<br>                                                                  RemotingCommand request) throws RemotingCommandException {<br>        final SendMessageContext mqtraceContext;<br>        switch (request.getCode()) {<br>            case RequestCode.CONSUMER_SEND_MSG_BACK:<br>                return this.asyncConsumerSendMsgBack(ctx, request);<br>            default:<br>                SendMessageRequestHeader requestHeader &#x3D; parseRequestHeader(request);<br>                if (requestHeader &#x3D;&#x3D; null) {<br>                    return CompletableFuture.completedFuture(null);<br>                }<br>                mqtraceContext &#x3D; buildMsgContext(ctx, requestHeader);<br>                this.executeSendMessageHookBefore(ctx, request, mqtraceContext);<br>                if (requestHeader.isBatch()) {<br>                    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);<br>                } else {<br>                    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);<br>                }<br>        }<br>    }<br>org.apache.rocketmq.broker.processor.SendMessageProcessor#asyncSendMessage<br>è¿™é‡Œä¸»è¦çš„æ˜¯å…³æ³¨ç¬¬61è¡Œä»£ç ï¼Œè¿›å…¥åˆ°Stroreï¼Œè¿è¡ŒasyncPutMessageã€‚</p>\n<p>private CompletableFuture<RemotingCommand> asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request,<br>                                                                SendMessageContext mqtraceContext,<br>                                                                SendMessageRequestHeader requestHeader) {<br>        final RemotingCommand response &#x3D; preSend(ctx, request, requestHeader);<br>        final SendMessageResponseHeader responseHeader &#x3D; (SendMessageResponseHeader)response.readCustomHeader();</p>\n<pre><code>    if (response.getCode() != -1) &#123;\n        return CompletableFuture.completedFuture(response);\n    &#125;\n\n    final byte[] body = request.getBody();\n\n    int queueIdInt = requestHeader.getQueueId();\n    TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());\n\n    if (queueIdInt &lt; 0) &#123;\n        queueIdInt = randomQueueId(topicConfig.getWriteQueueNums());\n    &#125;\n\n    MessageExtBrokerInner msgInner = new MessageExtBrokerInner();\n    msgInner.setTopic(requestHeader.getTopic());\n    msgInner.setQueueId(queueIdInt);\n\n    if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;\n        return CompletableFuture.completedFuture(response);\n    &#125;\n\n    msgInner.setBody(body);\n    msgInner.setFlag(requestHeader.getFlag());\n    Map&lt;String, String&gt; origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());\n    MessageAccessor.setProperties(msgInner, origProps);\n    msgInner.setBornTimestamp(requestHeader.getBornTimestamp());\n    msgInner.setBornHost(ctx.channel().remoteAddress());\n    msgInner.setStoreHost(this.getStoreHost());\n    msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());\n    String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName();\n    MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);\n    if (origProps.containsKey(MessageConst.PROPERTY_WAIT_STORE_MSG_OK)) &#123;\n        // There is no need to store &quot;WAIT=true&quot;, remove it from propertiesString to save 9 bytes for each message.\n        // It works for most case. In some cases msgInner.setPropertiesString invoked later and replace it.\n        String waitStoreMsgOKValue = origProps.remove(MessageConst.PROPERTY_WAIT_STORE_MSG_OK);\n        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n        // Reput to properties, since msgInner.isWaitStoreMsgOK() will be invoked later\n        origProps.put(MessageConst.PROPERTY_WAIT_STORE_MSG_OK, waitStoreMsgOKValue);\n    &#125; else &#123;\n        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));\n    &#125;\n\n    CompletableFuture&lt;PutMessageResult&gt; putMessageResult = null;\n    String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);\n    if (Boolean.parseBoolean(transFlag)) &#123;\n        if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;\n            response.setCode(ResponseCode.NO_PERMISSION);\n            response.setRemark(\n                    &quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1()\n                            + &quot;] sending transaction message is forbidden&quot;);\n            return CompletableFuture.completedFuture(response);\n        &#125;\n        putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner);\n    &#125; else &#123;\n        putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner);\n    &#125;\n    return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);\n&#125;\n</code></pre>\n<p>org.apache.rocketmq.store.CommitLog#asyncPutMessage<br>putMessageçš„è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä¸»è¦çœ‹ç¬¬åå…«è¡Œå¼€å§‹ï¼Œå¦‚æœæ˜¯å»¶è¿Ÿmqï¼Œåˆ™ä¼šå°†æ¶ˆæ¯æ”¾å…¥åˆ°topic&#x3D;SCHEDULE_TOPIC_XXXX,queueId&#x3D;delayLevel-1ä¸­</p>\n<p>public CompletableFuture<PutMessageResult> asyncPutMessage(final MessageExtBrokerInner msg) {<br>        &#x2F;&#x2F; Set the storage time<br>        msg.setStoreTimestamp(System.currentTimeMillis());<br>        &#x2F;&#x2F; Set the message body BODY CRC (consider the most appropriate setting<br>        &#x2F;&#x2F; on the client)<br>        msg.setBodyCRC(UtilAll.crc32(msg.getBody()));<br>        &#x2F;&#x2F; Back to Results<br>        AppendMessageResult result &#x3D; null;</p>\n<pre><code>    StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n\n    String topic = msg.getTopic();\n</code></pre>\n<p>&#x2F;&#x2F;        int queueId msg.getQueueId();<br>        final int tranType &#x3D; MessageSysFlag.getTransactionValue(msg.getSysFlag());<br>        if (tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_NOT_TYPE<br>                || tranType &#x3D;&#x3D; MessageSysFlag.TRANSACTION_COMMIT_TYPE) {<br>            &#x2F;&#x2F; Delay Delivery<br>            if (msg.getDelayTimeLevel() &gt; 0) {<br>                if (msg.getDelayTimeLevel() &gt; this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel()) {<br>                    msg.setDelayTimeLevel(this.defaultMessageStore.getScheduleMessageService().getMaxDelayLevel());<br>                }</p>\n<pre><code>            topic = TopicValidator.RMQ_SYS_SCHEDULE_TOPIC;\n            int queueId = ScheduleMessageService.delayLevel2QueueId(msg.getDelayTimeLevel());\n\n            // Backup real topic, queueId\n            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_TOPIC, msg.getTopic());\n            MessageAccessor.putProperty(msg, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msg.getQueueId()));\n            msg.setPropertiesString(MessageDecoder.messageProperties2String(msg.getProperties()));\n\n            msg.setTopic(topic);\n            msg.setQueueId(queueId);\n        &#125;\n    &#125;\n\n    InetSocketAddress bornSocketAddress = (InetSocketAddress) msg.getBornHost();\n    if (bornSocketAddress.getAddress() instanceof Inet6Address) &#123;\n        msg.setBornHostV6Flag();\n    &#125;\n\n    InetSocketAddress storeSocketAddress = (InetSocketAddress) msg.getStoreHost();\n    if (storeSocketAddress.getAddress() instanceof Inet6Address) &#123;\n        msg.setStoreHostAddressV6Flag();\n    &#125;\n\n    PutMessageThreadLocal putMessageThreadLocal = this.putMessageThreadLocal.get();\n    updateMaxMessageSize(putMessageThreadLocal);\n    if (!multiDispatch.isMultiDispatchMsg(msg)) &#123;\n        PutMessageResult encodeResult = putMessageThreadLocal.getEncoder().encode(msg);\n        if (encodeResult != null) &#123;\n            return CompletableFuture.completedFuture(encodeResult);\n        &#125;\n        msg.setEncodedBuff(putMessageThreadLocal.getEncoder().getEncoderBuffer());\n    &#125;\n    PutMessageContext putMessageContext = new PutMessageContext(generateKey(putMessageThreadLocal.getKeyBuilder(), msg));\n\n    long elapsedTimeInLock = 0;\n    MappedFile unlockMappedFile = null;\n\n    putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n    try &#123;\n        MappedFile mappedFile = this.mappedFileQueue.getLastMappedFile();\n        long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();\n        this.beginTimeInLock = beginLockTimestamp;\n\n        // Here settings are stored timestamp, in order to ensure an orderly\n        // global\n        msg.setStoreTimestamp(beginLockTimestamp);\n\n        if (null == mappedFile || mappedFile.isFull()) &#123;\n            mappedFile = this.mappedFileQueue.getLastMappedFile(0); // Mark: NewFile may be cause noise\n        &#125;\n        if (null == mappedFile) &#123;\n            log.error(&quot;create mapped file1 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());\n            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, null));\n        &#125;\n\n        result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n        switch (result.getStatus()) &#123;\n            case PUT_OK:\n                break;\n            case END_OF_FILE:\n                unlockMappedFile = mappedFile;\n                // Create a new file, re-write the message\n                mappedFile = this.mappedFileQueue.getLastMappedFile(0);\n                if (null == mappedFile) &#123;\n                    // XXX: warn and notify me\n                    log.error(&quot;create mapped file2 error, topic: &quot; + msg.getTopic() + &quot; clientAddr: &quot; + msg.getBornHostString());\n                    return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.CREATE_MAPEDFILE_FAILED, result));\n                &#125;\n                result = mappedFile.appendMessage(msg, this.appendMessageCallback, putMessageContext);\n                break;\n            case MESSAGE_SIZE_EXCEEDED:\n            case PROPERTIES_SIZE_EXCEEDED:\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, result));\n            case UNKNOWN_ERROR:\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n            default:\n                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.UNKNOWN_ERROR, result));\n        &#125;\n\n        elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginLockTimestamp;\n    &#125; finally &#123;\n        beginTimeInLock = 0;\n        putMessageLock.unlock();\n    &#125;\n\n    if (elapsedTimeInLock &gt; 500) &#123;\n        log.warn(&quot;[NOTIFYME]putMessage in lock cost time(ms)=&#123;&#125;, bodyLength=&#123;&#125; AppendMessageResult=&#123;&#125;&quot;, elapsedTimeInLock, msg.getBody().length, result);\n    &#125;\n\n    if (null != unlockMappedFile &amp;&amp; this.defaultMessageStore.getMessageStoreConfig().isWarmMapedFileEnable()) &#123;\n        this.defaultMessageStore.unlockMappedFile(unlockMappedFile);\n    &#125;\n\n    PutMessageResult putMessageResult = new PutMessageResult(PutMessageStatus.PUT_OK, result);\n\n    // Statistics\n    storeStatsService.getSinglePutMessageTopicTimesTotal(msg.getTopic()).add(1);\n    storeStatsService.getSinglePutMessageTopicSizeTotal(topic).add(result.getWroteBytes());\n\n    CompletableFuture&lt;PutMessageStatus&gt; flushResultFuture = submitFlushRequest(result, msg);\n    CompletableFuture&lt;PutMessageStatus&gt; replicaResultFuture = submitReplicaRequest(result, msg);\n    return flushResultFuture.thenCombine(replicaResultFuture, (flushStatus, replicaStatus) -&gt; &#123;\n        if (flushStatus != PutMessageStatus.PUT_OK) &#123;\n            putMessageResult.setPutMessageStatus(flushStatus);\n        &#125;\n        if (replicaStatus != PutMessageStatus.PUT_OK) &#123;\n            putMessageResult.setPutMessageStatus(replicaStatus);\n        &#125;\n        return putMessageResult;\n    &#125;);\n&#125;\n</code></pre>\n<p>org.apache.rocketmq.store.schedule.ScheduleMessageService#start<br>è¿™é‡Œä¸»è¦æ˜¯è§£é‡Šscheduleå¯¹æ¯ä¸€ä¸ªdelayLeveléƒ½å¯åŠ¨äº†ä¸€ä¸ªå®šæ—¶ä»»åŠ¡çº¿ç¨‹ï¼Œæ‰§è¡Œé¢‘ç‡æ ¹æ®ä¸åŒdelayLevelå¯¹åº”çš„deladeliveryTimeå†³å®šã€‚</p>\n<p>public void start() {<br>        if (started.compareAndSet(false, true)) {<br>            this.load();<br>            this.deliverExecutorService &#x3D; new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(â€œScheduleMessageTimerThread_â€));<br>            if (this.enableAsyncDeliver) {<br>                this.handleExecutorService &#x3D; new ScheduledThreadPoolExecutor(this.maxDelayLevel, new ThreadFactoryImpl(â€œScheduleMessageExecutorHandleThread_â€));<br>            }<br>            for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) {<br>                Integer level &#x3D; entry.getKey();<br>                Long timeDelay &#x3D; entry.getValue();<br>                Long offset &#x3D; this.offsetTable.get(level);<br>                if (null &#x3D;&#x3D; offset) {<br>                    offset &#x3D; 0L;<br>                }</p>\n<pre><code>            if (timeDelay != null) &#123;\n                if (this.enableAsyncDeliver) &#123;\n                    this.handleExecutorService.schedule(new HandlePutResultTask(level), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n                &#125;\n                this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME, TimeUnit.MILLISECONDS);\n            &#125;\n        &#125;\n\n        this.deliverExecutorService.scheduleAtFixedRate(new Runnable() &#123;\n\n            @Override\n            public void run() &#123;\n                try &#123;\n                    if (started.get()) &#123;\n                        ScheduleMessageService.this.persist();\n                    &#125;\n                &#125; catch (Throwable e) &#123;\n                    log.error(&quot;scheduleAtFixedRate flush exception&quot;, e);\n                &#125;\n            &#125;\n        &#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval(), TimeUnit.MILLISECONDS);\n    &#125;\n&#125;\n</code></pre>\n<p>org.apache.rocketmq.store.schedule.ScheduleMessageService.DeliverDelayedMessageTimerTask<br>taskä¸»è¦çš„ä»»åŠ¡å°±æ˜¯101è¡Œï¼Œè°ƒç”¨org.apache.rocketmq.store.schedule.ScheduleMessageService#messageTimeupï¼Œå°†å¯¹è±¡è½¬æ¢æˆMessageExtBrokerInnerå¯¹è±¡ï¼ˆå¹¶åœ¨æ­¤æ—¶å°†topicå’ŒqueueIdé‡ç½®æˆåŸæ¥çš„ï¼‰ï¼Œç„¶åè°ƒç”¨org.apache.rocketmq.store.DefaultMessageStore#putMessageï¼Œå°†æ¶ˆæ¯æ”¾å…¥åˆ°commitLogä¸­ã€‚</p>\n<p>class DeliverDelayedMessageTimerTask implements Runnable {<br>        private final int delayLevel;<br>        private final long offset;</p>\n<pre><code>    public DeliverDelayedMessageTimerTask(int delayLevel, long offset) &#123;\n        this.delayLevel = delayLevel;\n        this.offset = offset;\n    &#125;\n\n    @Override\n    public void run() &#123;\n        try &#123;\n            if (isStarted()) &#123;\n                this.executeOnTimeup();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            // XXX: warn and notify me\n            log.error(&quot;ScheduleMessageService, executeOnTimeup exception&quot;, e);\n            this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_PERIOD);\n        &#125;\n    &#125;\n\n    /**\n     * @return\n     */\n    private long correctDeliverTimestamp(final long now, final long deliverTimestamp) &#123;\n\n        long result = deliverTimestamp;\n\n        long maxTimestamp = now + ScheduleMessageService.this.delayLevelTable.get(this.delayLevel);\n        if (deliverTimestamp &gt; maxTimestamp) &#123;\n            result = now;\n        &#125;\n\n        return result;\n    &#125;\n\n    public void executeOnTimeup() &#123;\n        ConsumeQueue cq =\n            ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC,\n                delayLevel2QueueId(delayLevel));\n\n        if (cq == null) &#123;\n            this.scheduleNextTimerTask(this.offset, DELAY_FOR_A_WHILE);\n            return;\n        &#125;\n\n        SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);\n        if (bufferCQ == null) &#123;\n            long resetOffset;\n            if ((resetOffset = cq.getMinOffsetInQueue()) &gt; this.offset) &#123;\n                log.error(&quot;schedule CQ offset invalid. offset=&#123;&#125;, cqMinOffset=&#123;&#125;, queueId=&#123;&#125;&quot;,\n                    this.offset, resetOffset, cq.getQueueId());\n            &#125; else if ((resetOffset = cq.getMaxOffsetInQueue()) &lt; this.offset) &#123;\n                log.error(&quot;schedule CQ offset invalid. offset=&#123;&#125;, cqMaxOffset=&#123;&#125;, queueId=&#123;&#125;&quot;,\n                    this.offset, resetOffset, cq.getQueueId());\n            &#125; else &#123;\n                resetOffset = this.offset;\n            &#125;\n\n            this.scheduleNextTimerTask(resetOffset, DELAY_FOR_A_WHILE);\n            return;\n        &#125;\n\n        long nextOffset = this.offset;\n        try &#123;\n            int i = 0;\n            ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();\n            for (; i &lt; bufferCQ.getSize() &amp;&amp; isStarted(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;\n                long offsetPy = bufferCQ.getByteBuffer().getLong();\n                int sizePy = bufferCQ.getByteBuffer().getInt();\n                long tagsCode = bufferCQ.getByteBuffer().getLong();\n\n                if (cq.isExtAddr(tagsCode)) &#123;\n                    if (cq.getExt(tagsCode, cqExtUnit)) &#123;\n                        tagsCode = cqExtUnit.getTagsCode();\n                    &#125; else &#123;\n                        //can&#39;t find ext content.So re compute tags code.\n                        log.error(&quot;[BUG] can&#39;t find consume queue extend file content!addr=&#123;&#125;, offsetPy=&#123;&#125;, sizePy=&#123;&#125;&quot;,\n                            tagsCode, offsetPy, sizePy);\n                        long msgStoreTime = defaultMessageStore.getCommitLog().pickupStoreTimestamp(offsetPy, sizePy);\n                        tagsCode = computeDeliverTimestamp(delayLevel, msgStoreTime);\n                    &#125;\n                &#125;\n\n                long now = System.currentTimeMillis();\n                long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);\n                nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n\n                long countdown = deliverTimestamp - now;\n                if (countdown &gt; 0) &#123;\n                    this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                    return;\n                &#125;\n\n                MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);\n                if (msgExt == null) &#123;\n                    continue;\n                &#125;\n\n                MessageExtBrokerInner msgInner = ScheduleMessageService.this.messageTimeup(msgExt);\n                if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) &#123;\n                    log.error(&quot;[BUG] the real topic of schedule msg is &#123;&#125;, discard the msg. msg=&#123;&#125;&quot;,\n                        msgInner.getTopic(), msgInner);\n                    continue;\n                &#125;\n\n                boolean deliverSuc;\n                if (ScheduleMessageService.this.enableAsyncDeliver) &#123;\n                    deliverSuc = this.asyncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                &#125; else &#123;\n                    deliverSuc = this.syncDeliver(msgInner, msgExt.getMsgId(), nextOffset, offsetPy, sizePy);\n                &#125;\n\n                if (!deliverSuc) &#123;\n                    this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n                    return;\n                &#125;\n            &#125;\n\n            nextOffset = this.offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);\n        &#125; catch (Exception e) &#123;\n            log.error(&quot;ScheduleMessageService, messageTimeup execute error, offset = &#123;&#125;&quot;, nextOffset, e);\n        &#125; finally &#123;\n            bufferCQ.release();\n        &#125;\n\n        this.scheduleNextTimerTask(nextOffset, DELAY_FOR_A_WHILE);\n    &#125;\n\n    public void scheduleNextTimerTask(long offset, long delay) &#123;\n        ScheduleMessageService.this.deliverExecutorService.schedule(new DeliverDelayedMessageTimerTask(\n            this.delayLevel, offset), delay, TimeUnit.MILLISECONDS);\n    &#125;\n\n    private boolean syncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n        int sizePy) &#123;\n        PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, false);\n        PutMessageResult result = resultProcess.get();\n        boolean sendStatus = result != null &amp;&amp; result.getPutMessageStatus() == PutMessageStatus.PUT_OK;\n        if (sendStatus) &#123;\n            ScheduleMessageService.this.updateOffset(this.delayLevel, resultProcess.getNextOffset());\n        &#125;\n        return sendStatus;\n    &#125;\n\n    private boolean asyncDeliver(MessageExtBrokerInner msgInner, String msgId, long offset, long offsetPy,\n        int sizePy) &#123;\n        Queue&lt;PutResultProcess&gt; processesQueue = ScheduleMessageService.this.deliverPendingTable.get(this.delayLevel);\n\n        //Flow Control\n        int currentPendingNum = processesQueue.size();\n        int maxPendingLimit = ScheduleMessageService.this.defaultMessageStore.getMessageStoreConfig()\n            .getScheduleAsyncDeliverMaxPendingLimit();\n        if (currentPendingNum &gt; maxPendingLimit) &#123;\n            log.warn(&quot;Asynchronous deliver triggers flow control, &quot; +\n                &quot;currentPendingNum=&#123;&#125;, maxPendingLimit=&#123;&#125;&quot;, currentPendingNum, maxPendingLimit);\n            return false;\n        &#125;\n\n        //Blocked\n        PutResultProcess firstProcess = processesQueue.peek();\n        if (firstProcess != null &amp;&amp; firstProcess.need2Blocked()) &#123;\n            log.warn(&quot;Asynchronous deliver block. info=&#123;&#125;&quot;, firstProcess.toString());\n            return false;\n        &#125;\n\n        PutResultProcess resultProcess = deliverMessage(msgInner, msgId, offset, offsetPy, sizePy, true);\n        processesQueue.add(resultProcess);\n        return true;\n    &#125;\n\n    private PutResultProcess deliverMessage(MessageExtBrokerInner msgInner, String msgId, long offset,\n        long offsetPy, int sizePy, boolean autoResend) &#123;\n        CompletableFuture&lt;PutMessageResult&gt; future =\n            ScheduleMessageService.this.writeMessageStore.asyncPutMessage(msgInner);\n        return new PutResultProcess()\n            .setTopic(msgInner.getTopic())\n            .setDelayLevel(this.delayLevel)\n            .setOffset(offset)\n            .setPhysicOffset(offsetPy)\n            .setPhysicSize(sizePy)\n            .setMsgId(msgId)\n            .setAutoResend(autoResend)\n            .setFuture(future)\n            .thenProcess();\n    &#125;\n&#125;\n</code></pre>\n<p>RocketMQ 5.Xçš„å»¶æ—¶MQç°çŠ¶ å®˜æ–¹æ–‡æ¡£<br>å­—æ®µmessage.deliveryTimestamp<br>å¯ä»¥é¢„å®šè§¦å‘çš„æ—¶é—´æˆ³ï¼Œè€Œä¸æ˜¯å»¶æ—¶æ—¶é•¿<br>æ”¯æŒä»¥æ ¼å¼ä¸ºæ¯«ç§’çº§unixæ—¶é—´æˆ³ï¼ˆé»˜è®¤1000æ¯«ç§’çš„ç²¾åº¦ä¹Ÿå°±æ˜¯1ç§’ï¼‰<br>æ”¯æŒæœ€é•¿24å°æ—¶ï¼Œä¸æ”¯æŒè‡ªå®šä¹‰ä¿®æ”¹ï¼Œè¶…è¿‡24å°æ—¶å»¶æ—¶ä¸ç”Ÿæ•ˆï¼ŒæœåŠ¡ç«¯ä¼šç«‹å³æŠ•é€’<br>å®šæ—¶ä»»åŠ¡ä»…æ”¯æŒå‘é€åˆ°MessageTypeä¸ºDelayçš„Topicä¸­<br>RocketMQ 5.Xçš„å»¶æ—¶MQåŸç†è§£æ<br>RocketMQ 5.Xçš„å»¶æ—¶MQæºç è§£æ<br>å†™åœ¨æœ€å<br>     åœ¨2025å¹´09æœˆ18æ—¥ï¼Œå¿ƒè¡€æ¥æ½®åœ¨githubä¸Šæœç´¢rocketMQçš„å»¶è¿Ÿmqï¼Œå‘ç°äº†2018å¹´çš„ä¸€äº›ç‚¹ç‚¹æ»´æ»´ã€‚<br>     æœ‰è‡ªå·±ä¸ºäº†å­¦ä¹ aiå¹¶ä½œä¸ºæ¯•è®¾çš„ä»“åº“ï¼Œæœ‰åŒå­¦å¸¦æˆ‘ç©çš„hexo + githubå®ç°çš„ç®€å•ä¸ªäººåšå®¢ã€‚<br>     åœ¨çœ‹å®Œæ–‡æ¡£å’Œä»£ç ä¹‹åç™¾æ„Ÿäº¤é›†ï¼Œç»ˆäºæ‰“ç®—é‡æ–°å¼€å§‹å†™åšå®¢ã€‚ä¸çŸ¥é“è¿™æ¬¡è¿˜èƒ½åšæŒå¤šä¹…ï¼Œä½†æ˜¯æ—¢ç„¶è‡ªå·±èƒ½ä¸€å£æ°”å‡è‚¥æ‰äº†43æ–¤ï¼ˆæˆªè‡³ç›®å‰ï¼‰ï¼Œé‚£ä¹ˆè¿˜æœ‰ä»€ä¹ˆä¸èƒ½çš„å‘¢ï¼Ÿ<br>     åŠ æ²¹å§è‡ªå·±ï¼Œåœ¨æ²¡æœ‰ç›®æ ‡çš„æ—¶å€™å¥½å¥½ç§¯ç´¯ï¼Œåšç§¯è–„å‘ã€‚</p>\n"},{"_content":"","source":"_drafts/todo-list.md","raw":"","slug":"todo-list","published":0,"date":"2025-09-20T06:18:05.574Z","updated":"2025-09-20T06:19:33.310Z","_id":"cmfqwbur5000078u7879vflm7","title":"","comments":1,"layout":"post","photos":[],"content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"cmfqa7j9n0000k4u7eg5zauep","category_id":"cmfqa7j9q0001k4u7dcu13wqm","_id":"cmfqa7j9s0004k4u71rb1bsov"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","category_id":"cmfqf6qtl0001kgu7gr5da4wd","_id":"cmfqf6qto0007kgu76qx8c6x8"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","category_id":"cmfqf6qtn0004kgu77vo0bvzo","_id":"cmfqf6qto0008kgu75n86f9sl"}],"PostTag":[{"post_id":"cmfqa7j9n0000k4u7eg5zauep","tag_id":"cmfqa7j9r0002k4u70auagg1n","_id":"cmfqa7j9s0005k4u7d49ehavl"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","tag_id":"cmfqaawrm00002wu77uhfcxgw","_id":"cmfqf6qto0009kgu764z43yie"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","tag_id":"cmfqf6qtm0002kgu73imk89wb","_id":"cmfqf6qto000akgu72p5me3ha"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","tag_id":"cmfqf6qtn0003kgu7c2g94w08","_id":"cmfqf6qto000bkgu76vinfgf6"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","tag_id":"cmfqf6qto0005kgu75wq71oi4","_id":"cmfqf6qto000ckgu73nj6ay5b"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","tag_id":"cmfqf6qto0006kgu707qubog9","_id":"cmfqf6qto000dkgu712d68l5s"},{"post_id":"cmfqf6qtj0000kgu7a8n8a6iz","tag_id":"cmfqqo8zy000ekgu76meofylz","_id":"cmfqrejjx000gkgu79k7i9tw2"}],"Tag":[{"name":"Hexo","_id":"cmfqa7j9r0002k4u70auagg1n"},{"name":"åšå®¢","_id":"cmfqa7j9s0003k4u79i6p9yvi"},{"name":"Java","_id":"cmfqaawrm00002wu77uhfcxgw"},{"name":"Python","_id":"cmfqaawrn00012wu71h5vbcx2"},{"name":"AI","_id":"cmfqaawrn00022wu78t4fgs0c"},{"name":"RocketMQ","_id":"cmfqf6qtm0002kgu73imk89wb"},{"name":"åˆ†å¸ƒå¼","_id":"cmfqf6qtn0003kgu7c2g94w08"},{"name":"æ¶æ„","_id":"cmfqf6qto0005kgu75wq71oi4"},{"name":"æ¶ˆæ¯é˜Ÿåˆ—","_id":"cmfqf6qto0006kgu707qubog9"},{"name":"æºç ","_id":"cmfqqo8zy000ekgu76meofylz"}]}}